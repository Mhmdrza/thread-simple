<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>مدیریت توجه</title>

    <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
    <script>
        tailwind.config = {
            darkMode: 'class', // Controlled by JS
            theme: {
                extend: {
                    // Customizations can go here if needed
                    screens: {
                        'xs': '420px', // Extra small breakpoint for finer control
                    },
                    keyframes: {
                        'toast-in': {
                            '0%': { transform: 'translateY(100%)', opacity: '0' },
                            '100%': { transform: 'translateY(0)', opacity: '1' },
                        },
                        'toast-out': {
                            '0%': { transform: 'translateY(0)', opacity: '1' },
                            '100%': { transform: 'translateY(100%)', opacity: '0' },
                        },
                    },
                    animation: {
                        'toast-in': 'toast-in 0.3s ease-out forwards',
                        'toast-out': 'toast-out 0.3s ease-in forwards',
                    }
                }
            }
        }
    </script>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://unpkg.com/moment/min/moment.min.js"></script>
    <script src="https://unpkg.com/moment/locale/fa.js"></script>
    <script src="https://unpkg.com/moment-jalaali/build/moment-jalaali.js"></script>
    <script>
      // Ensure moment is globally available for moment-jalaali
      window.moment = moment;
    </script>

    <script src="https://unpkg.com/prop-types@15.8.1/prop-types.js"></script>


    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Vazirmatn', sans-serif;
            @apply bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-200 antialiased;
        }

        /* Style adjustments for better RTL */
        [dir="rtl"] {
            /* Add specific RTL overrides if Tailwind doesn't cover everything */
        }

        /* Custom scrollbar for better aesthetics (optional) */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            @apply bg-gray-100 dark:bg-gray-800 rounded-full;
        }
        ::-webkit-scrollbar-thumb {
            @apply bg-gray-400 dark:bg-gray-600 rounded-full;
        }
        ::-webkit-scrollbar-thumb:hover {
            @apply bg-gray-500 dark:bg-gray-500;
        }

        /* Define common button styles */
        .btn {
            @apply inline-flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-50 dark:focus:ring-offset-gray-900 transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed;
        }
        .btn-primary {
            @apply text-white bg-blue-600 hover:bg-blue-700 focus:ring-blue-500;
        }
        .btn-secondary {
            @apply text-gray-700 dark:text-gray-200 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 focus:ring-blue-500 border border-gray-300 dark:border-gray-600;
        }
         .btn-danger {
             @apply text-white bg-red-600 hover:bg-red-700 focus:ring-red-500;
         }
         .btn-success {
              @apply text-white bg-green-600 hover:bg-green-700 focus:ring-green-500;
         }
         .btn-warning {
              @apply text-gray-900 bg-yellow-400 hover:bg-yellow-500 focus:ring-yellow-300;
         }
        .btn-icon {
             @apply p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-gray-700 dark:hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500;
        }
        .btn-link {
            @apply text-blue-600 dark:text-blue-400 hover:underline focus:outline-none font-medium text-sm;
        }

        /* Common form input style */
        .input-field {
             @apply block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 text-sm disabled:opacity-50 disabled:bg-gray-100 dark:disabled:bg-gray-800;
        }
         /* Style for select elements */
        .select-field {
            @apply block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 text-sm disabled:opacity-50;
        }
         /* Textarea */
        .textarea-field {
             @apply block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 text-sm disabled:opacity-50;
        }
        /* Checkbox/Radio */
        .checkbox-field {
            @apply h-4 w-4 text-blue-600 border-gray-300 dark:border-gray-600 rounded focus:ring-blue-500 dark:bg-gray-700 dark:checked:bg-blue-600 dark:focus:ring-offset-gray-800;
        }


        /* Modal styles (simulates bottom sheet on mobile) */
        .modal-backdrop {
             @apply fixed inset-0 bg-black bg-opacity-60 backdrop-blur-sm flex justify-center items-end sm:items-center z-50;
        }
        .modal-content {
            @apply bg-white dark:bg-gray-800 rounded-t-lg sm:rounded-lg shadow-xl max-h-[90vh] max-w-full sm:max-w-lg w-full overflow-y-auto flex flex-col;
        }
         .modal-header {
             @apply p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center sticky top-0 bg-white dark:bg-gray-800 z-10;
         }
         .modal-body {
             @apply p-4 sm:p-6 flex-grow;
         }
         .modal-footer {
              @apply p-4 border-t border-gray-200 dark:border-gray-700 flex flex-col xs:flex-row justify-end gap-2 sticky bottom-0 bg-gray-50 dark:bg-gray-800;
         }

        /* Bottom Nav */
         .bottom-nav {
             @apply fixed bottom-0 left-0 right-0 h-16 bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 shadow-md flex justify-around items-center z-40;
         }
         .bottom-nav button {
             @apply flex flex-col items-center text-xs text-gray-500 dark:text-gray-400 p-1 sm:p-2 flex-grow basis-0 text-center;         }
         .bottom-nav button.active {
              @apply text-blue-600 dark:text-blue-400;
         }
         .bottom-nav button svg {
              @apply w-5 h-5 mb-1;
          }

        /* Toast Notifications */
        .toast-container {
            @apply fixed bottom-20 sm:bottom-4 right-4 left-4 sm:left-auto max-w-md z-[100] space-y-2;
        }
        .toast {
            @apply flex items-center justify-between w-full p-4 text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700;
            animation: toast-in 0.3s; /* Apply enter animation */
        }
         .toast.exiting {
            animation: toast-out 0.3s; /* Apply exit animation */
         }
        .toast-content {
            @apply text-sm font-normal;
        }
        .toast-undo {
            @apply -mx-1.5 -my-1.5 ms-3;
        }
    </style>
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript"> // Use TS preset for better hinting with PropTypes/JSDoc

        // --- Global Setup ---
        const { useState, useEffect, createContext, useContext, useCallback, useMemo, useRef, Fragment } = React;
        const PropTypes = window.PropTypes;
        moment.locale('fa'); // Set moment default locale globally

        // --- Constants & Defaults ---
        const STORAGE_KEY = 'attentionApp_data_v2'; // Incremented version
        const DEFAULT_LANG = 'fa';
        const DEFAULT_THEME = 'system';
        const DEFAULT_LOG_RETENTION_DAYS = 30;
        const TOAST_TIMEOUT = 7000; // 7 seconds for undo actions


        // --- Utility Functions ---
        const generateUUID = () => crypto.randomUUID();

        // --- Date/Time Utilities ---
        const formatDate = (date = undefined, format = 'jYYYY/jMM/jDD', lang = DEFAULT_LANG) => {
            try {
                const m = moment(date);
                if (!m.isValid()) return "Invalid Date";
                return m.locale(lang).format(format);
            } catch (e) {
                console.error("Date formatting error:", e);
                return "Date Error";
            }
        };
        const formatRelativeTime = (timestamp, lang = DEFAULT_LANG) => {
             try {
                 const m = moment(timestamp);
                 if (!m.isValid()) return "";
                 return m.locale(lang).fromNow();
             } catch (e) {
                 console.error("Relative time formatting error:", e);                 return "";
             }
         };

        // Converts various inputs to 'YYYY-MM-DD' Gregorian string
        const toStorageDateString = (dateInput) => {
            if (!dateInput) return null;
            const m = moment(dateInput); // Handles Date objects, timestamps, existing strings
            if (m.isValid()) return m.format('YYYY-MM-DD');
            // Try parsing as Jalali if it's likely a string input
            if (typeof dateInput === 'string') {
                const mj = moment.from(dateInput, 'fa', 'jYYYY/jMM/jDD'); // Common input format
                if (mj.isValid()) return mj.format('YYYY-MM-DD');
                 const mj2 = moment.from(dateInput, 'fa', 'jYYYY-MM-DD'); // Another common input format
                if (mj2.isValid()) return mj2.format('YYYY-MM-DD');
            }
            console.warn("Could not parse date input to storage format:", dateInput);
            return null; // Indicate failure
        };

         // Check if a date string is valid in 'YYYY-MM-DD' format
        const isValidStorageDate = (dateString) => {
            return moment(dateString, 'YYYY-MM-DD', true).isValid();
        };

        // Get today's date string in storage format
        const getTodayStorageString = () => moment().format('YYYY-MM-DD');

         // Basic Lunar Offset Calculation (Placeholder - Needs real data source for accuracy)
         // Returns estimated Gregorian YYYY-MM-DD
         const getApproxLunarOffsetDate = (year, eventRef, offset) => {
             // VERY rough estimates - REPLACE with accurate data or library
             const hijriEpochOffset = -11; // Approx days shift per Gregorian year
             let ramadanApproxDay = 270 + (year - 2024) * hijriEpochOffset; // Rough guess for Ramadan start day number in year
              let baseDate;

             switch (eventRef) {
                 case 'RamadanStart':
                     baseDate = moment().year(year).dayOfYear(ramadanApproxDay);
                     break;
                  case 'EidFitr':
                      baseDate = moment().year(year).dayOfYear(ramadanApproxDay + 30); // Ramadan + approx 30 days
                      break;
                   case 'Ashura':
                      baseDate = moment().year(year).dayOfYear(10 + (year - 2024) * hijriEpochOffset); // Muharram 10 approx
                       break;
                 default:
                     // Fallback or error if eventRef is unknown
                     baseDate = moment().year(year).startOf('year');
             }

             return baseDate.add(offset, 'days').format('YYYY-MM-DD');
         };


        // --- JSDoc Typedefs (Simulating TypeScript) ---
        /**
         * @typedef {'created' | 'in-progress' | 'blocked' | 'done' | 'cancelled'} TaskState
         * @typedef {'low' | 'medium' | 'high' | null} TaskPriority
         * @typedef {{ id: string, text: string, state: 'created' | 'done', createdAt: number }} SubTask
         * @typedef {{ generatorId: string, originalScheduledDate: string }} RecurringInstanceInfo
         * @typedef {{
         *   id: string,         *   title: string,
         *   description?: string,
         *   state: TaskState,
         *   shownOn: string | null, // 'YYYY-MM-DD' Gregorian storage format
         *   deadline?: string, // 'YYYY-MM-DD' Gregorian storage format         *   priority: TaskPriority,
         *   topics: string[],
         *   subTasks: SubTask[],
         *   updates: string[],
         *   recurringInstanceInfo?: RecurringInstanceInfo,
         *   createdAt: number,
         *   lastUpdatedAt: number,
         *   createdByUserId: string,
         *   assignedToUserId: string
         * }} Task
         * @typedef {{ id: string, taskId: string, userId: string, timestamp: number, dayString: string, data: UpdateData }} Update // 'YYYY-MM-DD' Gregorian storage format
         * @typedef {{
         *   type: 'task_created' | 'task_deleted' | 'task_cancelled' | 'app_opened' | 'task_viewed' | 'undo' | 'text_update' | 'description_update' | 'state_change' | 'priority_change' | 'deadline_update' | 'topic_update' | 'subtask_added' | 'subtask_deleted' | 'subtask_state_change' | 'delay' | 'scheduled' | 'recurring_instance_created' | 'reminder_created' | 'reminder_updated' | 'reminder_deleted' | 'reminder_dismissed' | 'generator_created' | 'generator_updated' | 'generator_deleted',
         *   from?: any,
         *   to?: any,
         *   content?: string,
         *   newDescription?: string,
         *   newDeadline?: string,
         *   added?: string[],
         *   removed?: string[],
         *   subTaskId?: string,
         *   subTaskText?: string,
         *   chosenDelay?: 'next_day' | 'next_week' | 'next_month' | 'custom',
         *   actualToDay?: string, // 'YYYY-MM-DD'
         *   reason?: string,
         *   shownOn?: string, // 'YYYY-MM-DD'
         *   generatorId?: string,
         *   revertedUpdateId?: string,
         *   reminderId?: string,
         * }} UpdateData
         * @typedef {{ dayString: string, tasks: string[], updates: string[] }} Day // dayString is 'YYYY-MM-DD' Gregorian storage format
         * @typedef {{ id: string, title: string, eventDate: string, calendarType: 'Jalali' | 'Gregorian' | 'Lunar', recurrenceRule: 'none' | 'yearly' | 'monthly', isDismissedToday: { [dayString: string]: boolean }, createdAt: number, lunarEventReference?: string, daysOffset?: number }} Reminder // eventDate is 'YYYY-MM-DD' Gregorian storage format for G/J, or base G date for Lunar offset calculation
         * @typedef {{
         *   type: 'daily' | 'weekly' | 'monthly' | 'yearly',
         *   interval: number, // e.g., 3 for every 3 days/weeks etc.
         *   daysOfWeek?: number[], // 0=Sunday, 6=Saturday (if type is weekly)
         *   dayOfMonth?: number, // 1-31 (if type is monthly) - needs adjustment for month length
         *   monthOfYear?: number, // 1-12 (if type is yearly)
         *   calendar: 'Jalali' | 'Gregorian', // Calendar context for dayOfMonth/monthOfYear
         * }} FrequencyRule
         * @typedef {{
          *   lunarEventReference: string; // e.g., 'RamadanStart'
          *   offset: number; // e.g., -10
          * }} LunarOffsetRule
         * @typedef {{
         *   id: string,
         *   title: string,
         *   baseTaskDetails: Pick<Task, 'title' | 'description' | 'priority' | 'topics' | 'subTasks'>, // Details to copy to new instances
         *   frequencyRule?: FrequencyRule, // One of these must exist
         *   lunarOffsetRule?: LunarOffsetRule, // One of these must exist
         *   startDate: string, // 'YYYY-MM-DD' - First date to potentially generate task
         *   endDate?: string, // Optional 'YYYY-MM-DD' - Last date to generate
         *   maxCount?: number, // Optional max number of instances
         *   generatedCount: number, // Counter for generated instances
         *   state: 'active' | 'paused' | 'completed',
         *   createdAt: number,
         * }} RecurringGenerator
         * @typedef {{ userId: string | null, tasks: { [id: string]: Task }, days: { [dayString: string]: Day }, updates: { [id: string]: Update }, reminders: { [id: string]: Reminder }, recurringGenerators: { [id: string]: RecurringGenerator }, topics: string[], settings: { theme: 'light' | 'dark' | 'system', language: 'fa' | 'en', logRetentionDays: number | 'infinite', lastSyncTimestamp?: number } }} AppData
         */
         /**
          * @typedef {{ id: string, message: string, type: 'success' | 'error' | 'info' | 'undo', undoAction?: () => void }} ToastMessage
          */

        // --- Default Seed Data ---
        /** @returns {AppData} */
        const getDefaultAppData = (userId) => {
            const today = getTodayStorageString();
            const task1Id = generateUUID();
            const task2Id = generateUUID();
            const task3Id = generateUUID();
             const subTask1Id = generateUUID();
             const subTask2Id = generateUUID();
            const recGen1Id = generateUUID();
            const rem1Id = generateUUID();
             const update1Id = generateUUID(); // Seed update for task 1 creation

            return {
                userId: userId,
                tasks: {
                    [task1Id]: { id: task1Id, title: 'خرید نان سنگک', description: 'از نانوایی سر کوچه', state: 'created', shownOn: today, priority: null, topics: ['خانه'], subTasks: [], updates: [update1Id], createdAt: Date.now() - 10000, lastUpdatedAt: Date.now() - 10000, createdByUserId: userId, assignedToUserId: userId },
                    [task2Id]: { id: task2Id, title: 'بررسی ایمیل‌های کاری', state: 'created', shownOn: today, priority: 'medium', topics: ['کار'], subTasks: [], updates: [], createdAt: Date.now() - 5000, lastUpdatedAt: Date.now() - 5000, createdByUserId: userId, assignedToUserId: userId },
                    [task3Id]: { id: task3Id, title: 'برنامه‌ریزی سفر شمال', description: 'رزرو ویلا، بررسی مسیر', state: 'created', shownOn: null, priority: 'high', topics: ['شخصی', 'سفر'], subTasks: [{id: subTask1Id, text: 'جستجوی ویلا در سایت‌ها', state: 'created', createdAt: Date.now()-2000}, {id: subTask2Id, text: 'تخمین هزینه بنزین', state: 'created', createdAt: Date.now()-1000}], updates: [], createdAt: Date.now(), lastUpdatedAt: Date.now(), createdByUserId: userId, assignedToUserId: userId },                },
                days: {
                    [today]: { dayString: today, tasks: [task1Id, task2Id], updates: [update1Id] }
                },
                updates: {
                    [update1Id]: { id: update1Id, taskId: task1Id, userId: userId, timestamp: Date.now() - 10000, dayString: today, data: { type: 'task_created' } }
                },
                reminders: {
                    [rem1Id]: { id: rem1Id, title: 'سالگرد ازدواج', eventDate: '2024-08-20', calendarType: 'Gregorian', recurrenceRule: 'yearly', isDismissedToday: {}, createdAt: Date.now() } // Example date
                },
                recurringGenerators: {
                    [recGen1Id]: {                        id: recGen1Id,
                        title: 'تماس هفتگی با والدین',
                        baseTaskDetails: { title: 'تماس با والدین', topics: ['خانواده'], priority: null, subTasks:[] },
                        frequencyRule: { type: 'weekly', interval: 1, daysOfWeek: [5], calendar: 'Jalali' }, // Fridays
                        startDate: today,
                        generatedCount: 0,
                        state: 'active',
                        createdAt: Date.now()
                    }
                },
                topics: ["کار", "شخصی", "خانه", "خانواده", "سفر", "آموزش"],
                settings: {
                    theme: DEFAULT_THEME,
                    language: DEFAULT_LANG,
                    logRetentionDays: DEFAULT_LOG_RETENTION_DAYS,
                }
            };
        };

        // --- Contexts ---
        const DataContext = createContext(null);
        const I18nContext = createContext(null);
        const ThemeContext = createContext(null);
        const ToastContext = createContext(null);

        // --- Sentry Placeholder ---
        const Sentry = {
            captureException: (error, context) => {
                console.error("Sentry Capture:", error, context);
                // Replace with actual Sentry SDK call
            },
            captureMessage: (message, level) => {
                console.log(`Sentry Message [${level || 'info'}]:`, message);
                 // Replace with actual Sentry SDK call
            }
            // Add other Sentry methods if needed
        };

        // --- Global Error Boundary ---
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null, errorInfo: null };
            }

            static getDerivedStateFromError(error) {
                return { hasError: true, error: error };
            }

            componentDidCatch(error, errorInfo) {
                this.setState({ errorInfo: errorInfo });
                console.error("Uncaught error:", error, errorInfo);
                 Sentry.captureException(error, { componentStack: errorInfo.componentStack });
            }

            render() {
                if (this.state.hasError) {
                    // You can render any custom fallback UI
                    return (
                        <div className="p-4 sm:p-6 min-h-screen flex flex-col justify-center items-center text-center">
                            <h1 className="text-2xl font-bold text-red-600 mb-4">اوه! خطایی رخ داده است.</h1>
                             <p className="text-gray-700 dark:text-gray-300 mb-4">متاسفانه در برنامه مشکلی پیش آمد. لطفا صفحه را رفرش کنید یا با پشتیبانی تماس بگیرید.</p>
                             {/* Optionally show error details in development */}
                              {true && this.state.error && (
                                  <pre className="mt-4 p-2 bg-red-100 text-red-800 rounded text-xs text-left overflow-auto max-w-full">
                                      {this.state.error.toString()}
                                      {this.state.errorInfo?.componentStack}
                                 </pre>
                              )}
                             <button onClick={() => window.location.reload()} className="mt-6 btn btn-primary">بارگذاری مجدد</button>
                        </div>
                    );
                }

                return this.props.children;
            }
        }
        ErrorBoundary.propTypes = { children: PropTypes.node };

        // --- Context Providers (with detailed logic) ---

        // Toast Provider needs to be outside DataProvider if DataProvider actions trigger toasts
         function ToastProvider({ children }) {
            const [toasts, setToasts] = useState([]);

            const addToast = useCallback((message, type = 'info', duration = TOAST_TIMEOUT, undoAction = null) => {
                const id = generateUUID();                /** @type {ToastMessage} */
                const newToast = { id, message, type, undoAction };

                setToasts(currentToasts => [...currentToasts, newToast]);

                // Auto-dismiss after duration
                setTimeout(() => {
                    removeToast(id);
                }, duration);

                return id; // Return id if needed to manually dismiss later
            }, []);

             const removeToast = useCallback((id) => {
                 // Add an 'exiting' state for animation before removal
                 setToasts(currentToasts =>
                     currentToasts.map(toast =>
                         toast.id === id ? { ...toast, exiting: true } : toast
                     )
                 );
                 // Actually remove after animation duration
                 setTimeout(() => {
                      setToasts(currentToasts => currentToasts.filter(toast => toast.id !== id));
                 }, 300); // Match animation duration

            }, []);

             // Function to be called by the Undo button on the toast
             const performUndo = useCallback((id) => {
                 setToasts(currentToasts => {
                     const toast = currentToasts.find(t => t.id === id);
                     if (toast && toast.undoAction) {
                         try {
                             toast.undoAction(); // Execute the undo logic passed from DataProvider
                         } catch (e) {
                              console.error("Undo action failed:", e);
                              Sentry.captureException(e, { extra: { context: 'Toast Undo Action' } });
                              // Optionally show a new error toast
                         }
                         // Remove the toast immediately after undo is clicked
                         return currentToasts.filter(t => t.id !== id);
                     }
                     return currentToasts; // Return unchanged if toast not found or no action
                 });
            }, []);


            const value = useMemo(() => ({ addToast, removeToast, performUndo }), [addToast, removeToast, performUndo]);

            return (
                <ToastContext.Provider value={value}>
                    {children}
                    {/* Toast Container */}
                    <div className="toast-container" dir="rtl"> {/* Ensure container respects RTL */}
                        {toasts.map((toast) => (
                            <div key={toast.id}
                                 className={`toast ${toast.exiting ? 'exiting' : ''} ${toast.type === 'error' ? 'border-red-500' : toast.type === 'success' ? 'border-green-500' : 'border-blue-500'}`}
                                 role="alert"
                            >
                                <div className="toast-content">
                                    {/* Add icons based on type maybe */}
                                    {toast.message}
                                </div>
                                <div className="flex items-center">
                                     {toast.type === 'undo' && toast.undoAction && (
                                         <button onClick={() => performUndo(toast.id)} className="btn btn-link toast-undo">بازگردانی</button> /* TODO: i18n */
                                      )}
                                    <button type="button" className="btn-icon toast-close" onClick={() => removeToast(toast.id)} aria-label="Close">
                                         <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd"></path></svg>
                                    </button>
                                 </div>
                            </div>
                        ))}                    </div>
                </ToastContext.Provider>
            );
         }
         ToastProvider.propTypes = { children: PropTypes.node };


        function DataProvider({ children }) {
            const [appData, setAppData] = useState(null);
            const [loading, setLoading] = useState(true);
            const [isSaving, setIsSaving] = useState(false);
            const [error, setError] = useState(null); // For critical load/save errors
            const { addToast } = useContext(ToastContext);

             // Ref to store the previous state for undo operations
             const previousAppDataRef = useRef(null);


            // --- Local Storage Interaction ---
            const loadDataFromStorage = useCallback(() => {
                try {
                    const storedData = localStorage.getItem(STORAGE_KEY);
                    if (storedData) {
                        const parsedData = JSON.parse(storedData);
                        // Simple validation
                        if (parsedData && parsedData.userId && parsedData.settings) {
                            return parsedData;
                        } else {
                            console.warn("Stored data seems invalid. Reinitializing.");
                            Sentry.captureMessage("Invalid data found in localStorage", "warning");
                            return null; // Treat as no data found
                        }
                    }
                    return null;
                } catch (e) {
                    console.error("Failed to load data from localStorage:", e);
                    setError("Failed to load data. Storage might be corrupt.");
                    Sentry.captureException(e, { extra: { context: 'localStorage Load' } });
                    return null; // Indicate failure
                }
            }, []);

             const saveDataToStorage = useCallback((dataToSave) => {
                if (!dataToSave) return;
                setIsSaving(true);
                try {
                    const stringifiedData = JSON.stringify(dataToSave);
                    localStorage.setItem(STORAGE_KEY, stringifiedData);
                     // Store for undo right after successful save
                     previousAppDataRef.current = dataToSave;
                } catch (e) {
                    console.error("Failed to save data to localStorage:", e);
                    setError("Failed to save data. Storage might be full or quota exceeded.");
                     addToast("خطا در ذخیره سازی اطلاعات!", 'error'); // i18n needed
                    Sentry.captureException(e, { extra: { context: 'localStorage Save' } });
                } finally {
                    setIsSaving(false);
                }
            }, [addToast]);

            // --- Initial Load ---
            useEffect(() => {
                const loadedData = loadDataFromStorage();
                if (loadedData) {
                    setAppData(loadedData);
                     previousAppDataRef.current = loadedData; // Set initial state for undo base
                } else if (error === null) { // Only initialize if no critical load error occurred
                    const newUserId = generateUUID();
                    const defaultData = getDefaultAppData(newUserId);
                    setAppData(defaultData);
                     previousAppDataRef.current = defaultData;
                    saveDataToStorage(defaultData); // Save the initial default data
                }
                setLoading(false);
            }, [loadDataFromStorage, saveDataToStorage, error]); // Dependency on 'error' to prevent re-init loop


             // --- Debounced Save on Change ---
             useEffect(() => {
                 // Don't save during initial load or if there was a critical error
                 if (loading || error || !appData) {
                     return;
                 }

                 // Debounce saving to avoid excessive writes
                 const handler = setTimeout(() => {
                     // Only save if the current state is different from the last saved undo state
                      if (appData !== previousAppDataRef.current) {
                         saveDataToStorage(appData);
                      }
                 }, 500); // Adjust debounce time as needed

                 return () => {
                     clearTimeout(handler);
                 };
             }, [appData, saveDataToStorage, loading, error]);


            // --- Core State Update Logic ---
            /**
             * Internal function to update appData state and handle previous state for undo.
             * @param {function(AppData): AppData | AppData} updater - Function or new state object.
             * @param {boolean} [skipUndo=false] - If true, doesn't update previousAppDataRef (e.g., for undo itself).
             */
            const updateState = useCallback((updater, skipUndo = false) => {
                setAppData(currentState => {
                    // Store the state *before* this update for potential undo
                    if (!skipUndo) {
                         previousAppDataRef.current = currentState;
                    }
                    // Apply the update
                    return typeof updater === 'function' ? updater(currentState) : updater;
                });
            }, []);


             // --- Undo Action ---
             const performUndo = useCallback((actionDescription) => {
                  const previousData = previousAppDataRef.current;
                  if (previousData && previousData !== appData) { // Ensure there's a previous state and it's different
                      // Restore the previous state, explicitly skipping undo history update for this action
                      updateState(previousData, true);
                       addToast(`${actionDescription} بازگردانی شد.`, 'success'); // i18n                       // Clear the ref? Or allow redo? For now, clear to prevent redo chain.
                       // previousAppDataRef.current = appData; // Or set it to the *current* state before undo? Need careful thought for multi-level undo/redo. Let's keep it simple: undo once.
                  } else {
                      addToast("امکان بازگردانی وجود ندارد.", 'info'); // i18n
                  }
             }, [appData, updateState, addToast]); // Depends on current appData to check if different

             // --- Logging ---
             /**
              * @param {Omit<Update, 'id' | 'timestamp' | 'userId' | 'dayString'>} updateDetails
              * @param {function(AppData): AppData} [stateUpdater] - Optional function to modify state *atomically* with the log.
              * @returns {string} The new update ID.
              */
             const logUpdate = useCallback((updateDetails, stateUpdater = null) => {
                 let newUpdateId = '';
                 updateState(prev => {
                     if (!prev?.userId) return prev; // Should not happen after load

                     newUpdateId = generateUUID();
                     const timestamp = Date.now();
                     const dayString = getTodayStorageString();

                     /** @type {Update} */
                     const newUpdate = {
                         id: newUpdateId,
                         userId: prev.userId,
                         timestamp,
                         dayString, // Log occurred on this day
                         taskId: updateDetails.taskId, // Keep taskId at top level for indexing
                         data: updateDetails.data // Contains type and specific payload
                     };

                     let intermediateState = {
                         ...prev,
                         updates: { ...prev.updates, [newUpdateId]: newUpdate },
                     };

                      // Update day entry for the log
                     const updatedDays = { ...intermediateState.days };
                     if (!updatedDays[dayString]) {
                         updatedDays[dayString] = { dayString: dayString, tasks: [], updates: [] };
                     }
                     updatedDays[dayString] = {
                         ...updatedDays[dayString],
                         updates: [...(updatedDays[dayString].updates || []), newUpdateId]
                     };
                     intermediateState.days = updatedDays;


                     // Link update to task if applicable
                     if (updateDetails.taskId && intermediateState.tasks[updateDetails.taskId]) {
                         const updatedTasks = { ...intermediateState.tasks };
                         updatedTasks[updateDetails.taskId] = {
                             ...updatedTasks[updateDetails.taskId],
                             updates: [...(updatedTasks[updateDetails.taskId].updates || []), newUpdateId],
                             lastUpdatedAt: timestamp // Always update task's modification time
                         };
                         intermediateState.tasks = updatedTasks;
                     }

                     // Apply the specific state modification passed in, if any
                     if (typeof stateUpdater === 'function') {
                         intermediateState = stateUpdater(intermediateState);
                     }

                     return intermediateState;
                 });
                 return newUpdateId; // Return the ID of the created log entry
             }, [updateState]);


            // --- Task CRUD ---
            const addTask = useCallback((taskData, showUndo = true) => {                const newId = generateUUID();
                const actionDescription = "ایجاد وظیفه"; // i18n
                updateState(prev => {
                     if (!prev?.userId) return prev;
                     const now = Date.now();
                     const shownOnStorage = toStorageDateString(taskData.shownOn);

                     /** @type {Task} */
                     const newTask = {
                         id: newId,
                         state: 'created',
                         priority: taskData.priority || null,
                         topics: taskData.topics || [],
                         subTasks: [], // Subtasks added separately
                         updates: [], // Will be linked by logUpdate
                         createdAt: now,
                         lastUpdatedAt: now,
                         createdByUserId: prev.userId,
                         assignedToUserId: prev.userId, // For MVP
                         ...taskData, // title, description, deadline (needs conversion), etc.
                         shownOn: shownOnStorage, // Use converted date
                         deadline: toStorageDateString(taskData.deadline), // Use converted date
                     };

                     const updatedTasks = { ...prev.tasks, [newId]: newTask };
                     const updatedDays = { ...prev.days };
                     if (newTask.shownOn) {
                         if (!updatedDays[newTask.shownOn]) {
                             updatedDays[newTask.shownOn] = { dayString: newTask.shownOn, tasks: [], updates: [] };
                         }
                         updatedDays[newTask.shownOn].tasks = [...updatedDays[newTask.shownOn].tasks, newId];
                     }
                     return { ...prev, tasks: updatedTasks, days: updatedDays };
                });

                // Log after state update
                 const updateId = logUpdate({ taskId: newId, data: { type: 'task_created' } });

                if (showUndo) {
                     addToast(`${actionDescription}: '${taskData.title}'`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription));
                 }

            }, [updateState, logUpdate, addToast, performUndo]);

             const updateTask = useCallback((taskId, updates, actionDescription, showUndo = false) => {
                 let originalTask = null; // Store for logging 'from' values

                 updateState(prev => {
                      originalTask = prev.tasks[taskId];
                     if (!originalTask) return prev; // Task not found

                     const updatesWithConvertedDates = { ...updates };
                     if (updates.shownOn !== undefined) {
                         updatesWithConvertedDates.shownOn = toStorageDateString(updates.shownOn);
                     }
                     if (updates.deadline !== undefined) {
                         updatesWithConvertedDates.deadline = toStorageDateString(updates.deadline);
                     }

                     const updatedTask = { ...originalTask, ...updatesWithConvertedDates, lastUpdatedAt: Date.now() };
                     const newTasks = { ...prev.tasks, [taskId]: updatedTask };
                     let newDays = { ...prev.days };

                     // Handle change in shownOn date (moving between days/backlog)
                     if (updatesWithConvertedDates.shownOn !== undefined && originalTask.shownOn !== updatedTask.shownOn) {
                          // Remove from old day
                         if (originalTask.shownOn && newDays[originalTask.shownOn]) {
                             newDays[originalTask.shownOn] = {
                                 ...newDays[originalTask.shownOn],
                                 tasks: newDays[originalTask.shownOn].tasks.filter(id => id !== taskId)
                             };
                         }
                         // Add to new day
                         if (updatedTask.shownOn) {
                             if (!newDays[updatedTask.shownOn]) {
                                 newDays[updatedTask.shownOn] = { dayString: updatedTask.shownOn, tasks: [], updates: [] };                             }
                              newDays[updatedTask.shownOn].tasks = [...newDays[updatedTask.shownOn].tasks, taskId];
                         }
                     }

                     return { ...prev, tasks: newTasks, days: newDays };
                 });

                  // Logging after state update (use originalTask for 'from' values)
                 if (originalTask) {
                     if (updates.state !== undefined && originalTask.state !== updates.state) {
                         logUpdate({ taskId, data: { type: 'state_change', from: originalTask.state, to: updates.state } });
                     }
                     if (updates.priority !== undefined && originalTask.priority !== updates.priority) {
                         logUpdate({ taskId, data: { type: 'priority_change', from: originalTask.priority, to: updates.priority } });
                     }
                     if (updates.title !== undefined && originalTask.title !== updates.title) {
                          logUpdate({ taskId, data: { type: 'text_update', content: `Title changed from "${originalTask.title}" to "${updates.title}"` } }); // More specific type?
                     }
                     if (updates.description !== undefined && originalTask.description !== updates.description) {
                          logUpdate({ taskId, data: { type: 'description_update', newDescription: updates.description } });
                     }
                      const newShownOn = toStorageDateString(updates.shownOn);
                     if (updates.shownOn !== undefined && originalTask.shownOn !== newShownOn) {
                         if (originalTask.shownOn === null && newShownOn !== null) {
                            logUpdate({ taskId, data: { type: 'scheduled', shownOn: newShownOn } });
                         } else if (originalTask.shownOn !== null && newShownOn !== null) {
                            // If using the Delay Modal, it should pass chosenDelay and reason
                             logUpdate({ taskId, data: { type: 'delay', chosenDelay: updates.chosenDelay || 'custom', actualToDay: newShownOn, reason: updates.reason } });
                         }
                         // Handle case moving back to backlog (newShownOn === null) if needed
                     }
                     const newDeadline = toStorageDateString(updates.deadline);
                      if (updates.deadline !== undefined && originalTask.deadline !== newDeadline) {
                          logUpdate({ taskId, data: { type: 'deadline_update', newDeadline: newDeadline } });
                      }
                       if (updates.topics !== undefined /* && !arraysAreEqual(originalTask.topics, updates.topics) */) { // Need array compare helper
                            logUpdate({ taskId, data: { type: 'topic_update', /* added: ..., removed: ... */ } }); // Need diff logic
                        }
                      // Add other field change logs
                 }

                 if (showUndo && actionDescription) {
                     addToast(`${actionDescription} انجام شد.`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription)); // i18n
                 }

            }, [updateState, logUpdate, addToast, performUndo]);

            const deleteTask = useCallback((taskId, showUndo = true) => {
                const taskToDelete = appData?.tasks[taskId];
                 if (!taskToDelete) return;
                 const actionDescription = "حذف وظیفه"; // i18n

                updateState(prev => {
                     const { [taskId]: _, ...remainingTasks } = prev.tasks; // Destructure to remove
                     const newDays = { ...prev.days };                     if (taskToDelete.shownOn && newDays[taskToDelete.shownOn]) {
                         newDays[taskToDelete.shownOn] = {
                             ...newDays[taskToDelete.shownOn],
                             tasks: newDays[taskToDelete.shownOn].tasks.filter(id => id !== taskId)
                         };
                     }
                      // Keep updates for history? Yes. Don't delete updates.
                     return { ...prev, tasks: remainingTasks, days: newDays };
                });

                logUpdate({ taskId, data: { type: 'task_deleted' } });

                 if (showUndo) {
                    addToast(`${actionDescription}: '${taskToDelete.title}'`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription));
                 }
            }, [appData?.tasks, updateState, logUpdate, addToast, performUndo]);


             // --- SubTask Logic ---
             const addSubTask = useCallback((taskId, subTaskText, showUndo = false) => {
                 if (!subTaskText.trim()) return;
                 const newSubId = generateUUID();
                 const actionDescription = "افزودن وظیفه فرعی"; // i18n

                 updateState(prev => {
                     const task = prev.tasks[taskId];
                     if (!task) return prev;
                     const now = Date.now();
                     /** @type {SubTask} */
                     const newSubTask = { id: newSubId, text: subTaskText.trim(), state: 'created', createdAt: now };
                     const updatedTask = {
                         ...task,
                         subTasks: [...(task.subTasks || []), newSubTask],
                         lastUpdatedAt: now
                     };
                     return { ...prev, tasks: { ...prev.tasks, [taskId]: updatedTask } };
                 });

                 logUpdate({ taskId, data: { type: 'subtask_added', subTaskId: newSubId, subTaskText: subTaskText.trim() } });

                  if (showUndo) {
                      addToast(`${actionDescription}: '${subTaskText.trim()}'`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription));
                  }
             }, [updateState, logUpdate, addToast, performUndo]);

             const updateSubTaskState = useCallback((taskId, subTaskId, newState, showUndo = false) => {
                 let originalSubTask = null;
                 const actionDescription = "تغییر وضعیت وظیفه فرعی"; // i18n

                 updateState(prev => {
                      const task = prev.tasks[taskId];
                      if (!task || !task.subTasks) return prev;
                      let found = false;
                      const updatedSubTasks = task.subTasks.map(sub => {
                          if (sub.id === subTaskId) {
                              originalSubTask = sub; // Capture for logging and undo description
                              found = true;
                              return { ...sub, state: newState };
                          }
                          return sub;
                      });
                      if (!found) return prev; // Subtask not found

                      const updatedTask = { ...task, subTasks: updatedSubTasks, lastUpdatedAt: Date.now() };
                      return { ...prev, tasks: { ...prev.tasks, [taskId]: updatedTask } };
                 });

                 if (originalSubTask) {
                     logUpdate({ taskId, data: { type: 'subtask_state_change', subTaskId, subTaskText: originalSubTask.text, from: originalSubTask.state, to: newState } });
                      if (showUndo) {
                          addToast(`${actionDescription}: '${originalSubTask.text}'`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription));
                      }
                 }
             }, [updateState, logUpdate, addToast, performUndo]);

             const deleteSubTask = useCallback((taskId, subTaskId, showUndo = true) => {
                  let originalSubTask = null;
                  const actionDescription = "حذف وظیفه فرعی"; // i18n

                 updateState(prev => {
                      const task = prev.tasks[taskId];
                      if (!task || !task.subTasks) return prev;
                      const updatedSubTasks = task.subTasks.filter(sub => {
                           if (sub.id === subTaskId) {
                               originalSubTask = sub; // Capture for logging and undo description
                               return false; // Exclude from new array
                           }
                           return true;
                       });
                      if (!originalSubTask) return prev; // Not found

                      const updatedTask = { ...task, subTasks: updatedSubTasks, lastUpdatedAt: Date.now() };
                      return { ...prev, tasks: { ...prev.tasks, [taskId]: updatedTask } };
                 });

                 if (originalSubTask) {
                     logUpdate({ taskId, data: { type: 'subtask_deleted', subTaskId, subTaskText: originalSubTask.text } });                      if (showUndo) {
                           addToast(`${actionDescription}: '${originalSubTask.text}'`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription));
                      }
                 }
             }, [updateState, logUpdate, addToast, performUndo]);


            // --- Reminder CRUD ---
             const addReminder = useCallback((reminderData, showUndo = true) => {
                 const newId = generateUUID();
                 const actionDescription = "ایجاد یادآور"; // i18n
                 updateState(prev => {
                      /** @type {Reminder} */
                      const newReminder = {
                          id: newId,
                          title: reminderData.title,
                          eventDate: toStorageDateString(reminderData.eventDate), // Convert input date
                          calendarType: reminderData.calendarType || 'Jalali',
                          recurrenceRule: reminderData.recurrenceRule || 'none',
                          isDismissedToday: {},
                          createdAt: Date.now(),
                          lunarEventReference: reminderData.lunarEventReference,
                          daysOffset: reminderData.daysOffset,
                      };
                     return { ...prev, reminders: { ...prev.reminders, [newId]: newReminder } };
                 });
                 logUpdate({ reminderId: newId, data: { type: 'reminder_created' } });
                  if (showUndo) {
                      addToast(`${actionDescription}: '${reminderData.title}'`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription));
                  }
             }, [updateState, logUpdate, addToast, performUndo]);

             const updateReminder = useCallback((reminderId, updates, actionDescription, showUndo = true) => {
                  updateState(prev => {
                       const originalReminder = prev.reminders[reminderId];
                       if (!originalReminder) return prev;

                        const updatesWithConvertedDates = { ...updates };
                         if (updates.eventDate !== undefined) {
                             updatesWithConvertedDates.eventDate = toStorageDateString(updates.eventDate);
                         }

                       const updatedReminder = { ...originalReminder, ...updatesWithConvertedDates };
                       return { ...prev, reminders: { ...prev.reminders, [reminderId]: updatedReminder } };
                  });
                   logUpdate({ reminderId: reminderId, data: { type: 'reminder_updated', /* Include changed fields */ } });
                    if (showUndo && actionDescription) {
                        addToast(`${actionDescription} انجام شد.`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription)); // i18n
                    }
             }, [updateState, logUpdate, addToast, performUndo]);

            const deleteReminder = useCallback((reminderId, showUndo = true) => {
                const reminderToDelete = appData?.reminders[reminderId];
                 if (!reminderToDelete) return;
                 const actionDescription = "حذف یادآور"; // i18n

                 updateState(prev => {
                     const { [reminderId]: _, ...remainingReminders } = prev.reminders;
                     return { ...prev, reminders: remainingReminders };
                 });
                  logUpdate({ reminderId: reminderId, data: { type: 'reminder_deleted' } });
                 if (showUndo) {
                      addToast(`${actionDescription}: '${reminderToDelete.title}'`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription));
                 }
            }, [appData?.reminders, updateState, logUpdate, addToast, performUndo]);

             const dismissReminderForToday = useCallback((reminderId, dayString) => {
                  updateState(prev => {
                       const reminder = prev.reminders[reminderId];
                       if (!reminder) return prev;
                       const updatedReminder = {
                           ...reminder,
                           isDismissedToday: {
                               ...(reminder.isDismissedToday || {}),
                               [dayString]: true
                           }
                       };
                       return { ...prev, reminders: { ...prev.reminders, [reminderId]: updatedReminder } };
                  });
                  logUpdate({ reminderId: reminderId, data: { type: 'reminder_dismissed', day: dayString } });
             }, [updateState, logUpdate]);

             // --- Recurring Generator CRUD --- (Similar pattern to Reminders)
             const addRecurringGenerator = useCallback((generatorData, showUndo = true) => {
                  const newId = generateUUID();
                  const actionDescription = "ایجاد وظیفه دوره‌ای"; // i18n
                  updateState(prev => {
                       /** @type {RecurringGenerator} */
                       const newGenerator = {
                           id: newId,
                           title: generatorData.title,
                           baseTaskDetails: generatorData.baseTaskDetails || {},
                           frequencyRule: generatorData.frequencyRule, // Validate structure
                            lunarOffsetRule: generatorData.lunarOffsetRule, // Validate structure
                            startDate: toStorageDateString(generatorData.startDate) || getTodayStorageString(),
                            endDate: toStorageDateString(generatorData.endDate),
                            maxCount: generatorData.maxCount,
                            generatedCount: 0,
                            state: 'active',
                            createdAt: Date.now(),
                       };
                        // Basic validation: Ensure one rule type exists
                        if (!newGenerator.frequencyRule && !newGenerator.lunarOffsetRule) {
                             console.error("Generator must have either frequencyRule or lunarOffsetRule");
                              // Maybe throw error or return early? Returning prev state for now.
                              addToast("خطا: قانون تکرار مشخص نشده.", 'error'); // i18n
                             return prev;
                        }
                        return { ...prev, recurringGenerators: { ...prev.recurringGenerators, [newId]: newGenerator } };
                  });
                  logUpdate({ generatorId: newId, data: { type: 'generator_created' } });
                   if (showUndo) {
                       addToast(`${actionDescription}: '${generatorData.title}'`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription));
                   }
             }, [updateState, logUpdate, addToast, performUndo]);

             const updateRecurringGenerator = useCallback((generatorId, updates, actionDescription, showUndo = true) => {
                 updateState(prev => {
                      const originalGenerator = prev.recurringGenerators[generatorId];
                      if (!originalGenerator) return prev;

                      const updatesWithConvertedDates = { ...updates };
                      if (updates.startDate !== undefined) {
                          updatesWithConvertedDates.startDate = toStorageDateString(updates.startDate);
                      }
                       if (updates.endDate !== undefined) {
                            updatesWithConvertedDates.endDate = toStorageDateString(updates.endDate);
                       }

                      const updatedGenerator = { ...originalGenerator, ...updatesWithConvertedDates };
                       // Add validation if needed (e.g., changing rule type)
                      return { ...prev, recurringGenerators: { ...prev.recurringGenerators, [generatorId]: updatedGenerator } };
                 });
                  logUpdate({ generatorId: generatorId, data: { type: 'generator_updated', /* include changes */ } });
                   if (showUndo && actionDescription) {
                        addToast(`${actionDescription} انجام شد.`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription)); // i18n
                   }
             }, [updateState, logUpdate, addToast, performUndo]);

             const deleteRecurringGenerator = useCallback((generatorId, showUndo = true) => {
                 const generatorToDelete = appData?.recurringGenerators[generatorId];
                  if (!generatorToDelete) return;
                  const actionDescription = "حذف وظیفه دوره‌ای"; // i18n

                  updateState(prev => {
                      const { [generatorId]: _, ...remainingGenerators } = prev.recurringGenerators;
                      // Should we delete generated tasks? NO. Keep them as independent tasks.
                      return { ...prev, recurringGenerators: remainingGenerators };
                  });
                   logUpdate({ generatorId: generatorId, data: { type: 'generator_deleted' } });
                  if (showUndo) {
                       addToast(`${actionDescription}: '${generatorToDelete.title}'`, 'undo', TOAST_TIMEOUT, () => performUndo(actionDescription));
                  }
             }, [appData?.recurringGenerators, updateState, logUpdate, addToast, performUndo]);


             // --- Topic Management ---
             const addTopic = useCallback((topicName) => {
                 if (!topicName || !topicName.trim()) return;
                 const trimmedTopic = topicName.trim();
                 updateState(prev => {
                     if (prev.topics.includes(trimmedTopic)) return prev; // Avoid duplicates
                     return { ...prev, topics: [...prev.topics, trimmedTopic].sort() }; // Keep sorted
                 });
                  // No log needed? Or maybe a settings change log?
             }, [updateState]);

             const deleteTopic = useCallback((topicName) => {
                  updateState(prev => {
                      const newTopics = prev.topics.filter(t => t !== topicName);
                       // Remove topic from all tasks using it
                       const updatedTasks = { ...prev.tasks };
                       Object.keys(updatedTasks).forEach(taskId => {
                            const task = updatedTasks[taskId];
                            if (task.topics?.includes(topicName)) {
                                updatedTasks[taskId] = {
                                    ...task,
                                    topics: task.topics.filter(t => t !== topicName),
                                    lastUpdatedAt: Date.now() // Mark task as updated
                                };
                                // Maybe log this task update?
                           }
                       });
                       return { ...prev, topics: newTopics, tasks: updatedTasks };
                  });
                  // Log topic deletion?
             }, [updateState]);

            // --- Settings Update ---
             const updateSettings = useCallback((newSettings) => {
                  updateState(prev => ({ ...prev, settings: { ...prev.settings, ...newSettings } }));
             }, [updateState]);


             // --- Sync Functions ---
             const pullData = useCallback(async () => {
                 const userId = appData?.userId;
                 const lang = appData?.settings?.language || DEFAULT_LANG;
                 if (!userId) {
                     addToast("خطا: شناسه کاربری یافت نشد.", 'error'); // i18n
                     return;
                 }
                 if (!window.confirm(translations[lang].pullWarning)) return;

                 addToast("در حال دریافت اطلاعات از سرور...", 'info'); // i18n
                 try {
                     const response = await fetch(`/api/sync/pull?userId=${userId}`, { // Adjust URL/method as needed
                         method: 'GET',
                         headers: { 'Content-Type': 'application/json' },
                     });

                     if (!response.ok) {
                         throw new Error(`Server responded with status ${response.status}`);
                     }

                     const serverData = await response.json();

                     // Basic validation of server data
                     if (serverData && serverData.userId && serverData.settings && serverData.tasks) {
                         // Server data OVERWRITES local data
                         updateState(serverData, true); // Skip undo for sync pull
                          // Persist immediately after successful pull
                          saveDataToStorage(serverData);
                          previousAppDataRef.current = serverData; // Update base for future undo

                         updateSettings({ lastSyncTimestamp: Date.now() }); // Update sync time locally
                          addToast(translations[lang].pullSuccess, 'success');

                          // Check for new assigned tasks (basic check)
                          let newTasksCount = 0;
                          const localTasksBeforePull = previousAppDataRef.current?.tasks || {};
                          for (const taskId in serverData.tasks) {
                               if (!localTasksBeforePull[taskId]) {
                                   const task = serverData.tasks[taskId];
                                   if (task.assignedToUserId === userId /* && task.createdByUserId !== userId */) { // Be more specific?
                                        newTasksCount++;
                                   }
                               }
                           }
                          if (newTasksCount > 0) {
                               addToast(`${newTasksCount} وظیفه جدید دریافت شد.`, 'info'); // i18n
                           }

                     } else {
                         throw new Error("Invalid data structure received from server.");
                     }

                 } catch (error) {
                     console.error("Pull failed:", error);
                     Sentry.captureException(error, { extra: { context: 'Sync Pull' } });
                     addToast(translations[lang].pullError, 'error');
                 }
             }, [appData?.userId, appData?.settings?.language, updateState, addToast, updateSettings, saveDataToStorage]);


             const pushData = useCallback(async () => {
                  const userId = appData?.userId;
                  const lang = appData?.settings?.language || DEFAULT_LANG;
                   if (!userId || !appData) {
                       addToast("خطا: اطلاعات برنامه یافت نشد.", 'error'); // i18n
                       return;
                   }

                  addToast("در حال ارسال اطلاعات به سرور...", 'info'); // i18n
                  try {
                       const response = await fetch('/api/sync/push', { // Adjust URL/method
                           method: 'POST',
                           headers: { 'Content-Type': 'application/json' },
                           body: JSON.stringify({ userId, data: appData }) // Send userId and full data
                       });

                       if (!response.ok) {
                           throw new Error(`Server responded with status ${response.status}`);
                       }

                        // Assuming server confirms success
                        updateSettings({ lastSyncTimestamp: Date.now() }); // Update sync time
                        addToast(translations[lang].pushSuccess, 'success');

                  } catch (error) {
                       console.error("Push failed:", error);
                       Sentry.captureException(error, { extra: { context: 'Sync Push' } });
                       addToast(translations[lang].pushError, 'error');
                  }
             }, [appData, updateSettings, addToast]);

             // --- Log Management ---
             const exportData = useCallback(() => {
                  if (!appData) {
                      addToast("خطا: اطلاعاتی برای خروجی گرفتن وجود ندارد.", 'error'); // i18n
                      return;
                  }
                  try {
                      const dataStr = JSON.stringify(appData, null, 2); // Pretty print JSON
                      const blob = new Blob([dataStr], { type: 'application/json' });
                      const url = URL.createObjectURL(blob);
                      const linkElement = document.createElement('a');
                      linkElement.setAttribute('href', url);
                      const timestamp = moment().format('YYYYMMDD_HHmmss');
                      linkElement.setAttribute('download', `attention_app_backup_${timestamp}.json`);
                      document.body.appendChild(linkElement); // Required for Firefox
                      linkElement.click();
                      document.body.removeChild(linkElement); // Clean up
                      URL.revokeObjectURL(url); // Free up memory
                      addToast("خروجی اطلاعات با موفقیت انجام شد.", 'success'); // i18n
                  } catch (e) {
                      console.error("Export failed:", e);
                      Sentry.captureException(e, { extra: { context: 'Data Export' } });
                       addToast("خطا در ایجاد خروجی اطلاعات.", 'error'); // i18n
                  }
             }, [appData, addToast]);

            const clearOldLogs = useCallback((daysToKeep) => {
                const lang = appData?.settings?.language || DEFAULT_LANG;
                 if (!appData || daysToKeep === 'infinite') {
                      addToast("تنظیمات پاکسازی گزارش‌ها نامعتبر است.", 'info'); // i18n
                     return;
                 }
                 if (!window.confirm(translations[lang].confirmClearLogs)) return;

                 const actionDescription = `پاکسازی گزارش‌های قدیمی‌تر از ${daysToKeep} روز`; // i18n

                 updateState(prev => {
                     const cutoffTimestamp = moment().subtract(daysToKeep, 'days').valueOf();
                     const updatesToKeep = {};
                     const updatesToRemoveIds = new Set();
                     for (const id in prev.updates) {
                         if (prev.updates[id].timestamp >= cutoffTimestamp) {
                             updatesToKeep[id] = prev.updates[id];
                         } else {
                             updatesToRemoveIds.add(id);
                         }
                     }

                      if (updatesToRemoveIds.size === 0) return prev; // No changes needed

                     // Clean updates array in tasks and days
                     const updatedTasks = { ...prev.tasks };
                      Object.keys(updatedTasks).forEach(taskId => {
                           const task = updatedTasks[taskId];
                           if (task.updates?.length > 0) {
                                const filteredUpdates = task.updates.filter(updId => !updatesToRemoveIds.has(updId));
                                if (filteredUpdates.length !== task.updates.length) {
                                    updatedTasks[taskId] = { ...task, updates: filteredUpdates };
                                }
                           }
                       });

                     const updatedDays = { ...prev.days };
                      Object.keys(updatedDays).forEach(dayStr => {
                           const day = updatedDays[dayStr];
                           if (day.updates?.length > 0) {
                                const filteredUpdates = day.updates.filter(updId => !updatesToRemoveIds.has(updId));
                                if (filteredUpdates.length !== day.updates.length) {
                                     updatedDays[dayStr] = { ...day, updates: filteredUpdates };
                                 }
                           }
                       });                     return {
                         ...prev,
                         updates: updatesToKeep,
                         tasks: updatedTasks,
                         days: updatedDays
                     };
                 });

                  addToast(`${actionDescription} انجام شد.`, 'success'); // i18n
                  // No undo for log clearing

             }, [appData, updateState, addToast]);


              // --- Recurrence/Reminder Generation ---
              const generateScheduledItems = useCallback(() => {
                   updateState(prev => {
                       if (loading || !prev?.userId) return prev; // Don't run during load or if no user

                       const today = getTodayStorageString();
                       let generatedTasksCount = 0;
                       let nextState = { ...prev }; // Start with current state

                       // 1. Check Recurring Tasks
                       Object.values(prev.recurringGenerators).forEach(gen => {
                           if (gen.state !== 'active') return;
                           if (gen.endDate && today > gen.endDate) return;
                           if (gen.maxCount && gen.generatedCount >= gen.maxCount) return;
                           if (today < gen.startDate) return;

                            let shouldGenerate = false;
                           let scheduledDate = today; // Assuming generation for today

                           // --- Evaluate Rules ---
                            if (gen.frequencyRule) {
                                const rule = gen.frequencyRule;
                                const startMoment = moment(gen.startDate);
                                const todayMoment = moment(today);                                const calendar = rule.calendar === 'Jalali' ? 'fa' : 'en';
                                const startMomentCal = moment(gen.startDate).locale(calendar);
                                const todayMomentCal = moment(today).locale(calendar);

                                 switch (rule.type) {
                                    case 'daily':
                                        if (rule.interval > 0) {
                                            const daysSinceStart = todayMoment.diff(startMoment, 'days');
                                             if (daysSinceStart >= 0 && (daysSinceStart % rule.interval === 0)) {
                                                 shouldGenerate = true;
                                             }
                                        }
                                        break;
                                     case 'weekly':
                                         if (rule.interval > 0 && rule.daysOfWeek && rule.daysOfWeek.length > 0) {
                                             const weeksSinceStart = todayMoment.diff(startMoment, 'weeks');
                                             // Check if it's an interval week AND the day of week matches
                                             if (weeksSinceStart >= 0 && (weeksSinceStart % rule.interval === 0)) {
                                                  // Moment day(): 0=Sun, 6=Sat. Match spec.
                                                  if (rule.daysOfWeek.includes(todayMoment.day())) {
                                                      shouldGenerate = true;
                                                  }
                                             }
                                         }
                                         break;
                                     case 'monthly':
                                          if (rule.interval > 0 && rule.dayOfMonth) {
                                               const monthsSinceStart = todayMomentCal.diff(startMomentCal, 'jMonths'); // Use jMonths for Jalali
                                               if (monthsSinceStart >= 0 && (monthsSinceStart % rule.interval === 0)) {
                                                   // Get day of month based on rule's calendar
                                                   const dayOfMonthToday = rule.calendar === 'Jalali' ? todayMomentCal.jDate() : todayMomentCal.date();
                                                    // Handle end of month (e.g., rule says 31st, month has 30)
                                                    const lastDayOfMonth = rule.calendar === 'Jalali' ? todayMomentCal.jDaysInMonth() : todayMomentCal.daysInMonth();
                                                   const targetDay = Math.min(rule.dayOfMonth, lastDayOfMonth);
                                                    if (dayOfMonthToday === targetDay) {
                                                         shouldGenerate = true;
                                                     }
                                                }
                                           }
                                           break;
                                       case 'yearly':
                                            if (rule.interval > 0 && rule.monthOfYear && rule.dayOfMonth) {
                                                 const yearsSinceStart = rule.calendar === 'Jalali' ? todayMomentCal.jYear() - startMomentCal.jYear() : todayMomentCal.year() - startMomentCal.year();
                                                 if (yearsSinceStart >= 0 && (yearsSinceStart % rule.interval === 0)) {
                                                      const targetMonth = rule.monthOfYear; // 1-12
                                                      const currentMonth = rule.calendar === 'Jalali' ? todayMomentCal.jMonth() + 1 : todayMomentCal.month() + 1;
                                                      if (currentMonth === targetMonth) {
                                                           const lastDayOfMonth = rule.calendar === 'Jalali' ? todayMomentCal.jDaysInMonth() : todayMomentCal.daysInMonth();
                                                           const targetDay = Math.min(rule.dayOfMonth, lastDayOfMonth);
                                                           const dayOfMonthToday = rule.calendar === 'Jalali' ? todayMomentCal.jDate() : todayMomentCal.date();
                                                            if (dayOfMonthToday === targetDay) {
                                                                shouldGenerate = true;
                                                             }
                                                       }
                                                  }
                                             }
                                             break;
                                  }
                            } else if (gen.lunarOffsetRule) {
                                const rule = gen.lunarOffsetRule;
                                const approxDate = getApproxLunarOffsetDate(moment(today).year(), rule.lunarEventReference, rule.offset);
                                 if (approxDate === today) {
                                     shouldGenerate = true;
                                 }
                            }

                            // --- Generate Task Instance ---
                            if (shouldGenerate) {
                                const alreadyGenerated = Object.values(nextState.tasks).some(t =>
                                    t.recurringInstanceInfo?.generatorId === gen.id && t.shownOn === scheduledDate
                                );

                                if (!alreadyGenerated) {
                                    console.log(`Generating recurring task for '${gen.title}' on ${scheduledDate}`);
                                    generatedTasksCount++;
                                    const newId = generateUUID();
                                    const now = Date.now();
                                    const baseDetails = gen.baseTaskDetails || {};
                                    const newTask = {
                                        id: newId,
                                        title: baseDetails.title || gen.title, // Fallback to generator title
                                        description: baseDetails.description,
                                        priority: baseDetails.priority || null,
                                        topics: baseDetails.topics || [],
                                        subTasks: (baseDetails.subTasks || []).map(st => ({ ...st, id: generateUUID(), state: 'created' })),
                                        state: 'created',
                                        shownOn: scheduledDate,
                                        recurringInstanceInfo: { generatorId: gen.id, originalScheduledDate: scheduledDate },
                                        updates: [],
                                        createdAt: now,
                                        lastUpdatedAt: now,
                                        createdByUserId: prev.userId, // System generated, but assign to user
                                        assignedToUserId: prev.userId,
                                    };

                                     // Update state immutably within this function
                                     nextState.tasks = { ...nextState.tasks, [newId]: newTask };
                                     if (!nextState.days[scheduledDate]) {
                                         nextState.days[scheduledDate] = { dayString: scheduledDate, tasks: [], updates: [] };
                                     }
                                     nextState.days[scheduledDate].tasks = [...nextState.days[scheduledDate].tasks, newId];
                                     nextState.recurringGenerators[gen.id] = { ...gen, generatedCount: gen.generatedCount + 1 };

                                     // Log update synchronously
                                     const updateId = generateUUID();
                                     nextState.updates = {...nextState.updates, [updateId]: { id: updateId, taskId: newId, userId: prev.userId, timestamp: now, dayString: getTodayStorageString(), data: { type: 'recurring_instance_created', generatorId: gen.id }}};
                                     // Link log to task and day
                                      nextState.tasks[newId].updates = [updateId];
                                      const logDayStr = getTodayStorageString();
                                      if (!nextState.days[logDayStr]) { nextState.days[logDayStr] = { dayString: logDayStr, tasks:[], updates:[] }; }
                                      nextState.days[logDayStr].updates = [...nextState.days[logDayStr].updates, updateId];
                                 }
                             }
                        }); // End forEach generator

                       // Return the potentially modified state
                       return nextState;

                   }); // End updateState

              }, [updateState, loading]);


              // Run generation check on initial load after data is ready
              useEffect(() => {
                  if (!loading && appData?.userId) {
                      generateScheduledItems();
                  }
              }, [loading, appData?.userId, generateScheduledItems]);



            // --- Context Value ---
            const value = useMemo(() => ({
                appData,
                loading,
                isSaving,
                error, // Expose critical load/save errors
                // Actions
                addTask,
                updateTask,
                deleteTask,
                addSubTask,
                updateSubTaskState,
                deleteSubTask,
                addReminder,
                updateReminder,
                deleteReminder,
                dismissReminderForToday,
                addRecurringGenerator,
                updateRecurringGenerator,
                deleteRecurringGenerator,
                addTopic,
                deleteTopic,
                updateSettings,
                pullData,
                pushData,
                exportData,
                clearOldLogs,
                logUpdate, // Expose if needed externally, though less common
                generateScheduledItems // Expose for manual trigger?
            }), [
                appData, loading, isSaving, error, addTask, updateTask, deleteTask, addSubTask, updateSubTaskState, deleteSubTask,
                addReminder, updateReminder, deleteReminder, dismissReminderForToday,
                addRecurringGenerator, updateRecurringGenerator, deleteRecurringGenerator,
                addTopic, deleteTopic, updateSettings, pullData, pushData, exportData, clearOldLogs, logUpdate, generateScheduledItems
            ]);

            return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
        }
        DataProvider.propTypes = { children: PropTypes.node };

        // --- I18n Provider (No changes from previous version needed) ---
        function I18nProvider({ children }) {
            const { appData, updateSettings } = useContext(DataContext);
            const language = appData?.settings?.language || DEFAULT_LANG;

            const setLanguage = useCallback((lang) => {
                if (['fa', 'en'].includes(lang)) {
                    updateSettings({ language: lang });
                    document.documentElement.lang = lang;
                    document.documentElement.dir = lang === 'fa' ? 'rtl' : 'ltr';
                    moment.locale(lang); // Update moment locale globally
                }            }, [updateSettings]);

            useEffect(() => {
                 document.documentElement.lang = language;
                 document.documentElement.dir = language === 'fa' ? 'rtl' : 'ltr';
                 moment.locale(language);
            }, [language]);

            const t = useCallback((key, options = {}) => {
                 let translation = translations[language]?.[key] || key;
                 // Basic interpolation {{var}}
                 Object.keys(options).forEach(optKey => {
                     translation = translation.replace(`{{${optKey}}}`, options[optKey]);
                 });
                 return translation;
            }, [language]);

             // Helper for pluralization (very basic)
             const tp = useCallback((keySingular, keyPlural, count) => {
                 const key = count === 1 ? keySingular : keyPlural;
                 return t(key, { count });
             }, [t]);

            const value = useMemo(() => ({ language, setLanguage, t, tp }), [language, setLanguage, t, tp]);

            return <I18nContext.Provider value={value}>{children}</I18nContext.Provider>;
        }
         I18nProvider.propTypes = { children: PropTypes.node };

        // --- Theme Provider (No changes from previous version needed) ---
         function ThemeProvider({ children }) {
             const { appData, updateSettings } = useContext(DataContext);
             const theme = appData?.settings?.theme || DEFAULT_THEME;

             const setTheme = useCallback((newTheme) => {
                  if (['light', 'dark', 'system'].includes(newTheme)) {
                     updateSettings({ theme: newTheme });
                 }
             }, [updateSettings]);

             useEffect(() => {
                 const root = window.document.documentElement;
                 const isDark =
                     theme === 'dark' ||
                     (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

                 root.classList.remove(isDark ? 'light' : 'dark');
                 root.classList.add(isDark ? 'dark' : 'light');
             }, [theme]);

              useEffect(() => {
                 const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                 const handleChange = () => {
                     if (theme === 'system') {
                          const isSystemDark = mediaQuery.matches;
                          const root = window.document.documentElement;
                          root.classList.remove(isSystemDark ? 'light' : 'dark');
                          root.classList.add(isSystemDark ? 'dark' : 'light');
                     }
                 };
                  if (theme === 'system') {
                      mediaQuery.addEventListener('change', handleChange);
                  }
                  return () => mediaQuery.removeEventListener('change', handleChange);
             }, [theme]);

             const value = useMemo(() => ({ theme, setTheme }), [theme, setTheme]);

             return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
         }
         ThemeProvider.propTypes = { children: PropTypes.node };


        // --- UI Components ---

        // Simple Icon Component Placeholder (Replaces broken Heroicons CDN usage)
        function Icon({ name, solid = false, className = "w-5 h-5 inline-block" }) {
            // Map common icon names to simple text/symbols or basic SVG placeholders
            const iconMap = {
                'home': '🏠', 'calendar-days': '📅', 'inbox-stack': '📥', 'chart-bar-square': '📊',
                'cog-6-tooth': '⚙️', 'plus': '+', 'x-mark': '✕', 'chevron-left': '<', 'chevron-right': '>',
                'trash': '🗑️', 'check': '✓', 'play': '▶', 'pause': '⏸️', 'arrow-path': '↻',
                'check-circle': '✓', 'play-circle': '▶', 'pause-circle': '||', 'x-circle': 'ⓧ', 'sparkles': '✨',
                'arrow-uturn-left': '↩️', 'calendar': '📅', 'list-bullet': '•', 'arrow-up-circle': '↑',
                'exclamation-triangle': '⚠️',
                // Add more mappings as needed
            };
            const iconContent = iconMap[name] || '?'; // Fallback to question mark

            // Using a span, adjust styling if specific SVG appearance is crucial later
            // The className prop is passed for sizing/color etc.
            return <span className={`${className} leading-none`} aria-hidden="true">{iconContent}</span>;
         }
         Icon.propTypes = { name: PropTypes.string.isRequired, solid: PropTypes.bool, className: PropTypes.string };

        // Modal Component
        function Modal({ isOpen, onClose, title, children, footerContent }) {
            const { t } = useContext(I18nContext);

            useEffect(() => {
                const handleEscape = (event) => {
                    if (event.key === 'Escape') {
                        onClose();
                    }
                };
                if (isOpen) {
                    document.body.style.overflow = 'hidden'; // Prevent background scrolling
                    document.addEventListener('keydown', handleEscape);
                } else {
                     document.body.style.overflow = '';
                }
                return () => {
                    document.body.style.overflow = '';
                    document.removeEventListener('keydown', handleEscape);
                };
            }, [isOpen, onClose]);

            if (!isOpen) return null;

            return (
                <div className="modal-backdrop" onClick={onClose} role="dialog" aria-modal="true" aria-labelledby="modal-title">
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <div className="modal-header">
                            <h3 id="modal-title" className="text-lg font-semibold">{title}</h3>
                            <button onClick={onClose} className="btn-icon" aria-label={t('close')}>
                                <Icon name="x-mark" />
                            </button>
                        </div>
                        <div className="modal-body">
                            {children}
                        </div>
                        {footerContent && (
                            <div className="modal-footer">
                                {footerContent}
                            </div>
                        )}
                    </div>
                </div>
            );
        }
        Modal.propTypes = {
            isOpen: PropTypes.bool.isRequired,
            onClose: PropTypes.func.isRequired,
            title: PropTypes.string.isRequired,
            children: PropTypes.node,
            footerContent: PropTypes.node
        };


        // Topic Chip Component
        function TopicChip({ topic, onClick = null, onRemove = null, size = 'sm' }) {
            // Basic color hashing for variety (simple)
            const hashCode = (str) => {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = str.charCodeAt(i) + ((hash << 5) - hash);
                }
                return hash;
            };
            const intToRGB = (i) => {
                const c = (i & 0x00FFFFFF).toString(16).toUpperCase();
                return "00000".substring(0, 6 - c.length) + c;
            }
             // Example Tailwind color pairs (text/bg) - Use a more robust mapping if needed
            const colorPairs = [
                "text-blue-800 bg-blue-100 dark:text-blue-200 dark:bg-blue-900",
                "text-green-800 bg-green-100 dark:text-green-200 dark:bg-green-900",
                "text-yellow-800 bg-yellow-100 dark:text-yellow-200 dark:bg-yellow-900",
                "text-purple-800 bg-purple-100 dark:text-purple-200 dark:bg-purple-900",
                "text-pink-800 bg-pink-100 dark:text-pink-200 dark:bg-pink-900",
                "text-indigo-800 bg-indigo-100 dark:text-indigo-200 dark:bg-indigo-900",
                "text-red-800 bg-red-100 dark:text-red-200 dark:bg-red-900",
                "text-gray-800 bg-gray-100 dark:text-gray-200 dark:bg-gray-700", // Default/fallback
            ];
            const colorIndex = Math.abs(hashCode(topic)) % colorPairs.length;
            const colorClass = colorPairs[colorIndex];
            const sizeClass = size === 'sm' ? 'px-2.5 py-0.5 text-xs' : 'px-3 py-1 text-sm';
             const clickableClass = onClick ? 'cursor-pointer hover:opacity-80' : '';
             const removableClass = onRemove ? 'pe-1' : ''; // Adjust padding if remove button exists

            return (
                <span
                    className={`inline-flex items-center ${sizeClass} font-medium rounded-full ${colorClass} ${clickableClass} ${removableClass}`}
                    onClick={onClick}
                >
                    {topic}
                    {onRemove && (
                        <button
                            onClick={(e) => { e.stopPropagation(); onRemove(topic); }}
                            className="ms-1.5 inline-flex items-center justify-center h-4 w-4 rounded-full text-inherit hover:bg-black/10 dark:hover:bg-white/10 focus:outline-none"
                             aria-label={`Remove ${topic}`}
                        >
                           &times; {/* Simple X */}
                        </button>
                    )}
                </span>
            );
        }
        TopicChip.propTypes = { topic: PropTypes.string.isRequired, onClick: PropTypes.func, onRemove: PropTypes.func, size: PropTypes.oneOf(['sm', 'md']) };


        // --- Task Components ---

         function TaskStateSelector({ currentState, onChange }) {
             const { t } = useContext(I18nContext);
             const states = ['created', 'in-progress', 'blocked', 'done', 'cancelled'];
             const stateDetails = {
                 created: { label: t('stateCreated'), color: 'bg-gray-500', icon: 'sparkles' },
                 'in-progress': { label: t('stateInProgress'), color: 'bg-blue-500', icon: 'play-circle' },
                 blocked: { label: t('stateBlocked'), color: 'bg-red-500', icon: 'pause-circle' },
                 done: { label: t('stateDone'), color: 'bg-green-500', icon: 'check-circle' },
                 cancelled: { label: t('stateCancelled'), color: 'bg-slate-500', icon: 'x-circle' },
             };

             // Basic dropdown for now, could be styled buttons
             return (
                 <select value={currentState} onChange={(e) => onChange(e.target.value)} className="select-field">
                     {states.map(s => (
                         <option key={s} value={s}>
                             {stateDetails[s].label}
                         </option>
                     ))}
                 </select>
             );
         }
         TaskStateSelector.propTypes = { currentState: PropTypes.string.isRequired, onChange: PropTypes.func.isRequired };


         function TaskPrioritySelector({ currentPriority, onChange }) {
             const { t } = useContext(I18nContext);
             const priorities = [
                 { value: null, label: t('priorityNone') },                 { value: 'low', label: t('priorityLow') },
                 { value: 'medium', label: t('priorityMedium') },
                 { value: 'high', label: t('priorityHigh') }
             ];
             return (
                 <select value={currentPriority || ''} onChange={(e) => onChange(e.target.value || null)} className="select-field">
                     {priorities.map(p => (
                         <option key={p.label} value={p.value || ''}>
                             {p.label}
                         </option>
                     ))}                 </select>
             );
         }
         TaskPrioritySelector.propTypes = { currentPriority: PropTypes.string, onChange: PropTypes.func.isRequired };


        function SubTaskList({ taskId, subTasks, readOnly = false }) {
             const { t } = useContext(I18nContext);
             const { updateSubTaskState, deleteSubTask, addSubTask } = useContext(DataContext);
             const [newSubTaskText, setNewSubTaskText] = useState('');

             const handleAddSubTask = (e) => {
                 e.preventDefault();
                 if (!readOnly) {
                     addSubTask(taskId, newSubTaskText, true); // Enable undo
                     setNewSubTaskText('');
                 }
             };

             const handleToggle = (subTaskId, currentState) => {
                 if (!readOnly) {
                     updateSubTaskState(taskId, subTaskId, currentState === 'done' ? 'created' : 'done', true); // Enable undo
                 }
             };

            const handleDelete = (subTaskId) => {
                 if (!readOnly) {
                      // Optional: Confirm before deleting subtask
                      deleteSubTask(taskId, subTaskId, true); // Enable undo
                 }
            };

             return (
                 <div className="space-y-2">
                      <h4 className="text-sm font-medium text-gray-600 dark:text-gray-400">{t('subTasks')}</h4>                     {(subTasks || []).length === 0 && !readOnly && (
                          <p className="text-xs text-gray-500 italic">{t('noSubTasks')}</p>
                     )}
                     <ul className="space-y-1">
                          {(subTasks || []).sort((a,b) => a.createdAt - b.createdAt).map(sub => (
                              <li key={sub.id} className="flex items-center group py-1">
                                   <input
                                       id={`subtask-${sub.id}`}
                                       type="checkbox"
                                       checked={sub.state === 'done'}
                                       onChange={() => handleToggle(sub.id, sub.state)}
                                       disabled={readOnly}
                                       className="checkbox-field me-2 ms-1 flex-shrink-0 disabled:opacity-100" // Keep visible when disabled
                                   />
                                   <label
                                       htmlFor={`subtask-${sub.id}`}
                                        className={`flex-grow text-sm ${sub.state === 'done' ? 'line-through text-gray-500 dark:text-gray-400' : ''} ${readOnly ? '' : 'cursor-pointer'}`}
                                   >
                                       {sub.text}
                                   </label>
                                   {!readOnly && (
                                       <button
                                           onClick={() => handleDelete(sub.id)}
                                           className="btn-icon p-1 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity ms-1 text-red-500 hover:bg-red-100 dark:hover:bg-red-900/50"
                                           aria-label={t('delete')}
                                       >
                                           <Icon name="trash" className="w-4 h-4" />
                                       </button>
                                   )}
                               </li>
                          ))}
                     </ul>
                     {!readOnly && (
                          <form onSubmit={handleAddSubTask} className="flex gap-2 pt-2">
                              <input
                                  type="text"
                                  value={newSubTaskText}
                                  onChange={e => setNewSubTaskText(e.target.value)}
                                  placeholder={t('addSubTaskPlaceholder')}
                                  className="input-field flex-grow text-sm"
                                  required
                              />
                              <button type="submit" className="btn btn-secondary text-sm flex-shrink-0">
                                   <Icon name="plus" className="w-4 h-4" />
                              </button>                          </form>
                     )}
                 </div>
             );
        }
         SubTaskList.propTypes = { taskId: PropTypes.string.isRequired, subTasks: PropTypes.array, readOnly: PropTypes.bool };


        // --- Task Form Component (Used in Modal) ---
        function TaskForm({ task, onSave, onCancel }) {
            const { appData } = useContext(DataContext); // For topics
            const { t, language } = useContext(I18nContext);
            const [formData, setFormData] = useState({
                title: task?.title || '',
                description: task?.description || '',
                state: task?.state || 'created',
                shownOn: task?.shownOn ? formatDate(task.shownOn, 'jYYYY/jMM/jDD', language) : '', // Display Jalali
                deadline: task?.deadline ? formatDate(task.deadline, 'jYYYY/jMM/jDD', language) : '', // Display Jalali
                priority: task?.priority || null,
                topics: task?.topics || [],
            });
            const [selectedTopics, setSelectedTopics] = useState(new Set(task?.topics || []));

            const availableTopics = useMemo(() => appData?.topics || [], [appData?.topics]);

            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            };

             const handleDateChange = (name, value) => {
                  // Basic validation guidance - needs proper picker
                  setFormData(prev => ({ ...prev, [name]: value }));
             };

            const handleTopicToggle = (topic) => {
                 setSelectedTopics(prev => {
                      const newSet = new Set(prev);
                      if (newSet.has(topic)) {
                           newSet.delete(topic);
                      } else {
                           newSet.add(topic);
                      }
                      setFormData(p => ({ ...p, topics: Array.from(newSet) })); // Keep formData in sync
                      return newSet;
                 });
             };

            const handleSubmit = (e) => {
                 e.preventDefault();
                 const dataToSave = {
                     ...formData,
                     // Convert dates back to storage format
                     shownOn: formData.shownOn ? toStorageDateString(formData.shownOn) : null,
                     deadline: formData.deadline ? toStorageDateString(formData.deadline) : null,
                 };
                 onSave(dataToSave);
            };

            return (
                <form onSubmit={handleSubmit} className="space-y-4">
                    <div>
                        <label htmlFor="title" className="block text-sm font-medium mb-1">{t('taskTitle')} <span className="text-red-500">*</span></label>
                        <input type="text" name="title" id="title" value={formData.title} onChange={handleChange} className="input-field" required />
                    </div>
                    <div>
                         <label htmlFor="description" className="block text-sm font-medium mb-1">{t('taskDescription')}</label>
                         <textarea name="description" id="description" value={formData.description} onChange={handleChange} rows="3" className="textarea-field"></textarea>
                    </div>
                     <div className="grid grid-cols-1 xs:grid-cols-2 gap-4">
                        <div>
                            <label htmlFor="shownOn" className="block text-sm font-medium mb-1">{t('taskShownOn')}</label>
                            {/* Needs a proper Jalali Date Picker Component */}
                            <input type="text" name="shownOn" id="shownOn" value={formData.shownOn} onChange={(e) => handleDateChange('shownOn', e.target.value)} placeholder={t('datePlaceholderJJJJMMDD')} className="input-field" />
                             <p className="text-xs text-gray-500 mt-1">{t('leaveEmptyForBacklog')}</p>
                         </div>
                         <div>
                             <label htmlFor="deadline" className="block text-sm font-medium mb-1">{t('taskDeadline')}</label>
                             {/* Needs a proper Jalali Date Picker Component */}
                             <input type="text" name="deadline" id="deadline" value={formData.deadline} onChange={(e) => handleDateChange('deadline', e.target.value)} placeholder={t('datePlaceholderOptional')} className="input-field" />
                         </div>
                    </div>
                    <div className="grid grid-cols-1 xs:grid-cols-2 gap-4">
                         <div>
                             <label className="block text-sm font-medium mb-1">{t('taskPriority')}</label>
                             <TaskPrioritySelector currentPriority={formData.priority} onChange={(p) => setFormData(prev => ({...prev, priority: p}))} />
                         </div>
                         <div>
                              <label className="block text-sm font-medium mb-1">{t('taskState')}</label>
                              <TaskStateSelector currentState={formData.state} onChange={(s) => setFormData(prev => ({...prev, state: s}))} />
                         </div>
                    </div>
                     <div>
                         <label className="block text-sm font-medium mb-1">{t('taskTopics')}</label>
                         <div className="flex flex-wrap gap-2 p-2 border dark:border-gray-600 rounded-md min-h-[40px]">
                             {availableTopics.length === 0 && <span className="text-xs text-gray-500">{t('noTopicsDefined')}</span>}
                             {availableTopics.map(topic => (
                                 <button
                                     key={topic}
                                     type="button"
                                     onClick={() => handleTopicToggle(topic)}
                                     className={`rounded-full px-3 py-1 text-xs border transition-colors ${selectedTopics.has(topic) ? 'bg-blue-100 dark:bg-blue-900 border-blue-300 dark:border-blue-700 text-blue-800 dark:text-blue-200' : 'bg-gray-100 dark:bg-gray-700 border-gray-300 dark:border-gray-600 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                                 >
                                     {topic}
                                 </button>
                              ))}
                         </div>
                          {/* Option to add new topic inline? Maybe later. */}
                     </div>

                     {/* Subtasks are handled separately in TaskDetailModal */}                     {/* Footer Buttons (Passed via props) */}
                </form>
            );
        }
        TaskForm.propTypes = { task: PropTypes.object, onSave: PropTypes.func.isRequired, onCancel: PropTypes.func.isRequired };

        // Task Card Component
         function TaskCard({ task, isYesterdayUntouched = false }) {
            const { updateTask, deleteTask } = useContext(DataContext);
            const { t, language } = useContext(I18nContext);
            const [isDetailModalOpen, setIsDetailModalOpen] = useState(false);

             const handleStateChange = (newState) => {
                 updateTask(task.id, { state: newState }, `تغییر وضعیت به ${t('state'+newState)}`, true); // Enable undo
             };

             const priorityClasses = { low: 'border-blue-400', medium: 'border-yellow-400', high: 'border-red-500' };
             const stateClasses = {
                 created: 'border-gray-300 dark:border-gray-600',
                 'in-progress': 'border-blue-500',                 blocked: 'border-red-500',
                 done: 'border-green-500 opacity-70 dark:opacity-60', // Dim completed tasks
                 cancelled: 'border-gray-400 opacity-60 dark:opacity-50 line-through', // Dim and strike cancelled
             };
             const stateTextClass = {
                 created: 'text-gray-600 dark:text-gray-400',
                 'in-progress': 'text-blue-600 dark:text-blue-400',
                 blocked: 'text-red-600 dark:text-red-400',
                 done: 'text-green-600 dark:text-green-400',
                 cancelled: 'text-gray-500 dark:text-gray-500',             };
              const priorityTextClass = {
                  low: 'text-blue-600 dark:text-blue-400',
                  medium: 'text-yellow-600 dark:text-yellow-400',
                  high: 'text-red-600 dark:text-red-400',
              };

             const doneSubTasks = task.subTasks?.filter(st => st.state === 'done').length || 0;
             const totalSubTasks = task.subTasks?.length || 0;

            return (
                <Fragment>
                    <div
                        className={`relative bg-white dark:bg-gray-800 shadow-md rounded-lg mb-4 border-l-4 ${stateClasses[task.state] || stateClasses.created} ${task.priority ? priorityClasses[task.priority] : 'border-transparent'} transition-opacity duration-150`}
                        data-task-id={task.id}
                    >
                         {isYesterdayUntouched && (
                              <span className="absolute top-0 ltr:right-0 rtl:left-0 -mt-2 ltr:-mr-2 rtl:-ml-2 z-10 inline-flex items-center bg-yellow-100 text-yellow-800 text-xs font-bold px-2 py-1 rounded-full shadow">
                                 <Icon name="exclamation-triangle" className="w-3 h-3 me-1" />
                                {t('needsAttention')}
                              </span>
                          )}

                        <div className="p-3 sm:p-4">
                            <div className="flex justify-between items-start gap-2 mb-1">
                                 <h3                                     className={`font-semibold text-base sm:text-lg flex-grow cursor-pointer hover:text-blue-600 dark:hover:text-blue-400 ${task.state === 'cancelled' ? 'line-through': ''}`}
                                     onClick={() => setIsDetailModalOpen(true)}
                                 >
                                     {task.title}
                                 </h3>
                                 {task.priority && (
                                      <span className={`text-xs font-medium flex-shrink-0 ${priorityTextClass[task.priority]}`}>
                                         ({t(`priority${task.priority.charAt(0).toUpperCase() + task.priority.slice(1)}`)})
                                     </span>
                                  )}
                            </div>

                             {/* State Display */}
                              <p className={`text-xs font-medium mb-2 ${stateTextClass[task.state]}`}>
                                  {t(`state${task.state.charAt(0).toUpperCase() + task.state.slice(1).replace('-', '')}`)}
                              </p>

                             {task.description && <p className="text-sm text-gray-600 dark:text-gray-400 mb-2 line-clamp-2">{task.description}</p>}

                             {/* Sub-task Progress */}
                             {totalSubTasks > 0 && (
                                  <p className="text-xs text-gray-500 dark:text-gray-400 mb-2">                                      <Icon name="list-bullet" className="w-3 h-3 inline-block me-1" />
                                       {doneSubTasks} / {totalSubTasks} {t('subTasks')}
                                  </p>
                              )}

                             {/* Topics */}
                             {(task.topics?.length > 0) && (
                                 <div className="flex flex-wrap gap-1 mb-3">
                                     {task.topics.map(topic => <TopicChip key={topic} topic={topic} size="sm" />)}
                                 </div>
                              )}

                            {/* Dates */}
                            <div className="flex flex-wrap gap-x-3 gap-y-1 text-xs text-gray-500 dark:text-gray-400 mb-3">
                                {task.deadline && (
                                    <span className="flex items-center" title={t('taskDeadline')}>
                                        <Icon name="calendar-days" className="w-3 h-3 me-1 text-red-500" />
                                         {formatDate(task.deadline, 'jYY/jM/jD', language)}
                                     </span>
                                )}
                                <span className="flex items-center" title={t('lastUpdatedAt')}>
                                     <Icon name="arrow-path" className="w-3 h-3 me-1" />
                                     {formatRelativeTime(task.lastUpdatedAt, language)}
                                 </span>
                             </div>

                             {/* Quick State Change Actions (Only if not done/cancelled) */}
                             {task.state !== 'done' && task.state !== 'cancelled' && (
                                 <div className="flex flex-wrap gap-2 pt-2 border-t border-gray-100 dark:border-gray-700 mt-3">
                                     {task.state !== 'in-progress' && (
                                         <button onClick={() => handleStateChange('in-progress')} className="btn btn-secondary btn-xs flex items-center gap-1">
                                             <Icon name="play" className="w-4 h-4"/> {t('startAction')}
                                         </button>
                                     )}
                                     {task.state === 'in-progress' && (
                                         <button onClick={() => handleStateChange('done')} className="btn btn-success btn-xs flex items-center gap-1">
                                             <Icon name="check" className="w-4 h-4"/> {t('completeAction')}
                                          </button>
                                     )}
                                     {task.state !== 'blocked' && (
                                         <button onClick={() => handleStateChange('blocked')} className="btn btn-warning btn-xs flex items-center gap-1">
                                             <Icon name="pause" className="w-4 h-4"/> {t('blockAction')}
                                         </button>
                                      )}
                                      {task.state === 'blocked' && (
                                          <button onClick={() => handleStateChange('created')} className="btn btn-secondary btn-xs flex items-center gap-1">
                                              <Icon name="arrow-uturn-left" className="w-4 h-4"/> {t('unblockAction')}
                                          </button>
                                       )}
                                     {/* Add Delay button? Or keep in modal */}
                                     <button onClick={() => setIsDetailModalOpen(true)} className="btn btn-link btn-xs ms-auto">{t('details')}</button>
                                 </div>
                             )}
                              {/* Actions for done/cancelled tasks */}
                              {(task.state === 'done' || task.state === 'cancelled') && (
                                  <div className="flex justify-end pt-2 border-t border-gray-100 dark:border-gray-700 mt-3">
                                     <button onClick={() => handleStateChange('created')} className="btn btn-secondary btn-xs">{t('reopenAction')}</button>
                                     <button onClick={() => setIsDetailModalOpen(true)} className="btn btn-link btn-xs ms-2">{t('details')}</button>
                                  </div>
                               )}

                        </div>
                    </div>

                    {/* Detail Modal */}
                    <TaskDetailModal
                        isOpen={isDetailModalOpen}
                        onClose={() => setIsDetailModalOpen(false)}                        taskId={task.id}
                    />
                </Fragment>
            );
        }
        TaskCard.propTypes = { task: PropTypes.object.isRequired, isYesterdayUntouched: PropTypes.bool };


        // --- Task Detail Modal ---
        function TaskDetailModal({ isOpen, onClose, taskId }) {
            const { appData, updateTask, deleteTask } = useContext(DataContext);
            const { t, language } = useContext(I18nContext);
            const [isEditing, setIsEditing] = useState(false);

            const task = appData?.tasks[taskId];             // State for delay modal
            const [isDelayModalOpen, setIsDelayModalOpen] = useState(false);
            const [delayReason, setDelayReason] = useState('');
             const [delayDate, setDelayDate] = useState(getTodayStorageString()); // Default to today for picker


            const handleSave = (formData) => {
                 updateTask(taskId, formData, "ویرایش وظیفه", true); // Enable undo
                 setIsEditing(false);
                 // Keep modal open after edit? Or close? Closing for now.
                 // onClose();
            };

            const handleDeleteConfirm = () => {
                 if (window.confirm(t('confirmDeleteTask', { title: task?.title }))) {
                      deleteTask(taskId, true); // Enable undo
                      onClose(); // Close modal after delete
                 }
            };

             const handleOpenDelayModal = () => {
                 setDelayDate(moment(task?.shownOn || getTodayStorageString()).add(1, 'day').format('YYYY-MM-DD')); // Default to next day
                 setDelayReason('');
                 setIsDelayModalOpen(true);
             };

             const handleConfirmDelay = (chosenDelay) => {
                  const newShownOn = toStorageDateString(delayDate);
                  if (!newShownOn) {
                      alert(t('invalidDate')); // i18n
                      return;
                  }
                  updateTask(taskId, {
                      shownOn: newShownOn,
                      reason: delayReason, // Pass reason for logging
                      chosenDelay: chosenDelay // Pass chosen option for logging
                  }, "تاخیر وظیفه", true); // Enable undo
                  setIsDelayModalOpen(false);
                   onClose(); // Close detail modal after delay             
                };


            if (!isOpen || !task) return null;

            const modalTitle = isEditing ? t('editTaskTitle') : task.title;
            const footerContent = isEditing ? (
                <Fragment>
                    <button type="button" onClick={() => setIsEditing(false)} className="btn btn-secondary">{t('cancel')}</button>
                    {/* Submit button is inside the TaskForm */}
                     <button type="submit" form="task-edit-form" className="btn btn-primary">{t('saveChanges')}</button>
                </Fragment>
            ) : (
                <Fragment>
                     <button type="button" onClick={handleDeleteConfirm} className="btn btn-danger ltr:mr-auto rtl:ml-auto">{t('delete')}</button>
                     {task.state !== 'done' && task.state !== 'cancelled' && (
                          <button type="button" onClick={handleOpenDelayModal} className="btn btn-secondary">{t('delayTask')}</button>
                     )}
                    <button type="button" onClick={() => setIsEditing(true)} className="btn btn-primary">{t('edit')}</button>
                    <button type="button" onClick={onClose} className="btn btn-secondary">{t('close')}</button>
                </Fragment>
            );


            return (
                <Fragment>
                    <Modal isOpen={isOpen} onClose={onClose} title={modalTitle} footerContent={footerContent}>                        {isEditing ? (
                            <TaskForm key={taskId} /* Force re-render on edit toggle */ task={task} onSave={handleSave} onCancel={() => setIsEditing(false)} />
                        ) : (
                            <div className="space-y-4">
                                {/* Read-only Task Details */}
                                {task.description && <p className="text-sm whitespace-pre-wrap">{task.description}</p>}
                                <div className="grid grid-cols-2 gap-4 text-sm">
                                    <div><span className="font-medium text-gray-500 dark:text-gray-400">{t('taskState')}:</span> {t(`state${task.state.charAt(0).toUpperCase() + task.state.slice(1).replace('-', '')}`)}</div>
                                     <div><span className="font-medium text-gray-500 dark:text-gray-400">{t('taskPriority')}:</span> {task.priority ? t(`priority${task.priority.charAt(0).toUpperCase() + task.priority.slice(1)}`) : t('priorityNone')}</div>
                                    <div><span className="font-medium text-gray-500 dark:text-gray-400">{t('taskShownOn')}:</span> {task.shownOn ? formatDate(task.shownOn, 'jYYYY/jMM/jDD', language) : t('backlog')}</div>
                                    <div><span className="font-medium text-gray-500 dark:text-gray-400">{t('taskDeadline')}:</span> {task.deadline ? formatDate(task.deadline, 'jYYYY/jMM/jDD', language) : t('none')}</div>
                                     <div><span className="font-medium text-gray-500 dark:text-gray-400">{t('createdAt')}:</span> {formatDate(task.createdAt, 'jYYYY/jMM/jDD HH:mm', language)}</div>
                                      <div><span className="font-medium text-gray-500 dark:text-gray-400">{t('lastUpdatedAt')}:</span> {formatDate(task.lastUpdatedAt, 'jYYYY/jMM/jDD HH:mm', language)}</div>
                                </div>
                                 {task.topics && task.topics.length > 0 && (
                                      <div>
                                          <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">{t('taskTopics')}</h4>
                                          <div className="flex flex-wrap gap-1">
                                               {task.topics.map(topic => <TopicChip key={topic} topic={topic} size="sm" />)}
                                           </div>
                                      </div>
                                  )}

                                <SubTaskList taskId={taskId} subTasks={task.subTasks} readOnly={false} />

                                {/* TODO: Show update history for this task? */}
                            </div>
                        )}
                    </Modal>

                    {/* Delay Task Modal */}
                     <Modal
                         isOpen={isDelayModalOpen}
                         onClose={() => setIsDelayModalOpen(false)}
                         title={t('delayTaskTitle')}
                         footerContent={(
                             <Fragment>
                                 <button type="button" onClick={() => setIsDelayModalOpen(false)} className="btn btn-secondary">{t('cancel')}</button>
                                 <button type="button" onClick={() => handleConfirmDelay('custom')} className="btn btn-primary">{t('confirmDelay')}</button>
                             </Fragment>
                         )}
                     >
                          <div className="space-y-4">
                              <p className="text-sm">{t('delayTaskPrompt', { title: task?.title })}</p>
                              {/* Quick Delay Buttons */}
                              <div className="flex flex-wrap gap-2">
                                   <button onClick={() => {setDelayDate(moment(task?.shownOn || getTodayStorageString()).add(1, 'day').format('YYYY-MM-DD')); handleConfirmDelay('next_day'); }} className="btn btn-secondary btn-sm">{t('delayNextDay')}</button>
                                   <button onClick={() => {setDelayDate(moment(task?.shownOn || getTodayStorageString()).add(1, 'week').format('YYYY-MM-DD')); handleConfirmDelay('next_week'); }} className="btn btn-secondary btn-sm">{t('delayNextWeek')}</button>
                                   <button onClick={() => {setDelayDate(moment(task?.shownOn || getTodayStorageString()).add(1, 'month').format('YYYY-MM-DD')); handleConfirmDelay('next_month'); }} className="btn btn-secondary btn-sm">{t('delayNextMonth')}</button>
                              </div>
                               {/* Custom Date Picker */}
                              <div>
                                   <label htmlFor="delayDate" className="block text-sm font-medium mb-1">{t('delayCustomDate')}</label>
                                    {/* Needs a proper Jalali Date Picker Component */}
                                    <input
                                         id="delayDate"
                                         type="text"
                                         value={delayDate} // Store as YYYY-MM-DD
                                         onChange={e => setDelayDate(e.target.value)}
                                         placeholder="YYYY-MM-DD"
                                         className="input-field"
                                    />
                                    <p className="text-xs text-gray-500 mt-1">Format YYYY-MM-DD. Jalali: {formatDate(delayDate, 'jYYYY/jMM/jDD', language)}</p>
                              </div>
                               {/* Optional Reason */}
                               <div>
                                    <label htmlFor="delayReason" className="block text-sm font-medium mb-1">{t('delayReasonOptional')}</label>
                                    <input
                                         id="delayReason"
                                         type="text"
                                         value={delayReason}
                                         onChange={e => setDelayReason(e.target.value)}
                                         className="input-field"
                                    />
                               </div>
                          </div>
                     </Modal>                </Fragment>
            );
        }
        TaskDetailModal.propTypes = { isOpen: PropTypes.bool.isRequired, onClose: PropTypes.func.isRequired, taskId: PropTypes.string.isRequired };


        // --- Reminder Components ---
        function ReminderCard({ reminder, currentDayString }) {
             const { dismissReminderForToday } = useContext(DataContext);
             const { t, language } = useContext(I18nContext);

              const isDismissed = reminder.isDismissedToday?.[currentDayString];
              if (isDismissed) return null; // Don't show dismissed reminders

              // Calculate display date based on type
              let displayDateStr = '';
              if (reminder.calendarType === 'Lunar' && reminder.lunarEventReference) {
                   // Show the target Gregorian date calculated for today's year
                   const approxDate = getApproxLunarOffsetDate(moment(currentDayString).year(), reminder.lunarEventReference, reminder.daysOffset || 0);
                   displayDateStr = `${formatDate(approxDate, 'jYYYY/jMM/jDD', language)} (${t('lunarApprox')})`;
              } else {                   // For Gregorian/Jalali, show the base date formatted
                   displayDateStr = formatDate(reminder.eventDate, 'jYYYY/jMM/jDD', language);
              }

            return (
                 <div className="bg-purple-50 dark:bg-purple-900/30 border-l-4 border-purple-400 shadow rounded-lg p-3 mb-3 flex justify-between items-center gap-2">
                      <div className="flex-grow">
                          <h4 className="font-semibold text-sm text-purple-800 dark:text-purple-200">{reminder.title}</h4>
                           <p className="text-xs text-purple-700 dark:text-purple-300">
                              {displayDateStr}
                              {reminder.recurrenceRule !== 'none' && ` (${t(reminder.recurrenceRule)})`}
                           </p>
                      </div>
                       <button onClick={() => dismissReminderForToday(reminder.id, currentDayString)} className="btn-icon p-1 text-purple-500 hover:bg-purple-100 dark:hover:bg-purple-800" title={t('dismiss')}>
                           <Icon name="check" className="w-4 h-4" />
                       </button>
                 </div>
             );
        }
        ReminderCard.propTypes = { reminder: PropTypes.object.isRequired, currentDayString: PropTypes.string.isRequired };

         // --- Reminder Form (Simplified Example) ---
         // ... Implement a form similar to TaskForm for creating/editing Reminders ...


        // --- Recurring Generator Components ---
         // ... Implement Card and Form components for RecurringGenerators ...


        // --- Views ---

         // Helper to get tasks for a specific day, considering recurrence generation
         const useTasksForDay = (dayString) => {
             const { appData } = useContext(DataContext);
             return useMemo(() => {
                 if (!appData) return [];
                 const dayData = appData.days[dayString];
                 const taskIds = dayData?.tasks || [];
                 // Map IDs to task objects, filtering out any potential inconsistencies
                 return taskIds.map(id => appData.tasks[id]).filter(Boolean);
             }, [appData?.tasks, appData?.days, dayString]);
         };

        // Helper to get reminders for a specific day
        const useRemindersForDay = (dayString) => {
             const { appData } = useContext(DataContext);
             const todayMoment = moment(dayString);

             return useMemo(() => {
                 if (!appData) return [];
                 return Object.values(appData.reminders).filter(rem => {
                      const eventMoment = moment(rem.eventDate); // Assumes YYYY-MM-DD storage
                      if (!eventMoment.isValid()) return false;

                      // Check non-recurring first
                      if (rem.recurrenceRule === 'none') {
                           return rem.eventDate === dayString;
                      }

                      // Check yearly for Gregorian/Jalali
                      if (rem.recurrenceRule === 'yearly' && ['Gregorian', 'Jalali'].includes(rem.calendarType)) {
                           const format = rem.calendarType === 'Jalali' ? 'jMM-jDD' : 'MM-DD';
                           return eventMoment.format(format) === todayMoment.format(format);
                      }

                      // Check monthly for Gregorian/Jalali                       
                      if (rem.recurrenceRule === 'monthly' && ['Gregorian', 'Jalali'].includes(rem.calendarType)) {
                            const dayFormat = rem.calendarType === 'Jalali' ? 'jDD' : 'DD';
                            // Handle end of month mismatches
                            const targetDay = parseInt(eventMoment.format(dayFormat), 10);
                             const lastDayOfCurrentMonth = rem.calendarType === 'Jalali' ? todayMoment.jDaysInMonth() : todayMoment.daysInMonth();
                             const currentDay = parseInt(todayMoment.format(dayFormat), 10);
                             return currentDay === Math.min(targetDay, lastDayOfCurrentMonth);
                       }

                      // Check Lunar Offset
                      if (rem.calendarType === 'Lunar' && rem.lunarEventReference) {
                           const approxDate = getApproxLunarOffsetDate(todayMoment.year(), rem.lunarEventReference, rem.daysOffset || 0);
                           return approxDate === dayString;
                      }

                     return false; // Default: don't show
                 });
             }, [appData?.reminders, dayString]);
         };


        function TodayView() {
            const { appData, loading, addTask } = useContext(DataContext);
            const { t, language } = useContext(I18nContext);
            const [newTaskTitle, setNewTaskTitle] = useState('');
            const [currentDayString, setCurrentDayString] = useState(getTodayStorageString()); // Use storage format internally

            const tasksForDay = useTasksForDay(currentDayString);
            const remindersForDay = useRemindersForDay(currentDayString);

            // Motivation label check
            const yesterdayString = useMemo(() => moment(currentDayString).subtract(1, 'day').format('YYYY-MM-DD'), [currentDayString]);
            const untouchedYesterdayTasks = useMemo(() => {
                if (!appData || currentDayString !== getTodayStorageString()) return new Set(); // Only check when viewing today

                const yesterdayTaskIds = appData.days[yesterdayString]?.tasks || [];
                 const untouchedIds = new Set();
                yesterdayTaskIds.forEach(id => {
                    const task = appData.tasks[id];
                    // Check if task exists and is still in 'created' state
                    if (task && task.state === 'created') {
                         // Also check if it was *supposed* to be shown yesterday
                         if (task.shownOn === yesterdayString) {
                            untouchedIds.add(id);
                         }
                    }
                 });
                 return untouchedIds;            }, [appData, yesterdayString, currentDayString]);


            const handleQuickAdd = (e) => {
                e.preventDefault();
                if (!newTaskTitle.trim()) return;
                addTask({ title: newTaskTitle.trim(), shownOn: currentDayString }, true); // Enable undo
                setNewTaskTitle('');
            };

            const changeDay = (amount) => {
                 setCurrentDayString(moment(currentDayString).add(amount, 'days').format('YYYY-MM-DD'));
            };

            // --- Task Creation Modal ---
            const [isAddTaskModalOpen, setIsAddTaskModalOpen] = useState(false);
            const handleSaveNewTask = (formData) => {
                 // Ensure shownOn defaults to current view if not specified
                 const shownOn = formData.shownOn ? toStorageDateString(formData.shownOn) : currentDayString;                 addTask({ ...formData, shownOn: shownOn }, true); // Enable undo
                 setIsAddTaskModalOpen(false);
            };


            if (loading && !appData) return <AppLoadingIndicator />; // Show full page loading

            const isToday = currentDayString === getTodayStorageString();

            return (
                <div className="pb-24"> {/* Padding bottom for nav + quick add */}
                    {/* Header with Day Navigation */}
                    <div className="sticky top-0 z-30 bg-gray-50 dark:bg-gray-900/80 backdrop-blur-sm pt-3 pb-2 shadow-sm">
                        <div className="px-4 flex justify-between items-center">
                            <button onClick={() => changeDay(-1)} className="btn-icon" aria-label={t('previousDay')}>
                                <Icon name={language === 'fa' ? "chevron-right" : "chevron-left"} className="w-6 h-6" />
                             </button>
                             <h2 className="text-lg sm:text-xl font-semibold text-center">
                                {formatDate(currentDayString, 'dddd, jD jMMMM jYYYY', language)}
                                {isToday && <span className="text-xs font-normal text-blue-600 dark:text-blue-400 ms-1">({t('today')})</span>}
                            </h2>
                             <button onClick={() => changeDay(1)} className="btn-icon" aria-label={t('nextDay')}>
                                  <Icon name={language === 'fa' ? "chevron-left" : "chevron-right"} className="w-6 h-6" />
                              </button>
                        </div>
                    </div>

                    {/* Main Content Area */}
                    <div className="p-4 space-y-4">
                        {/* Reminders Section */}
                         <div>
                             {/* <h3 className="text-xs font-semibold uppercase text-gray-500 dark:text-gray-400 mb-2">{t('reminders')}</h3> */}
                             {remindersForDay.length === 0 && <p className="text-center text-xs text-gray-400 dark:text-gray-500 py-2 italic">{t('noRemindersForDay')}</p>}
                             {remindersForDay.map(rem => <ReminderCard key={rem.id} reminder={rem} currentDayString={currentDayString} />)}
                         </div>

                         {/* Tasks Section */}
                        <div>
                            {/* <h3 className="text-xs font-semibold uppercase text-gray-500 dark:text-gray-400 mb-2">{t('tasks')}</h3> */}
                             {tasksForDay.length === 0 && (
                                 <p className="text-center text-sm text-gray-500 dark:text-gray-400 py-6 italic">{t('noTasksForDay')}</p>
                             )}
                             {tasksForDay.map(task => (
                                 <TaskCard
                                     key={task.id}
                                     task={task}
                                     isYesterdayUntouched={isToday && untouchedYesterdayTasks.has(task.id)}
                                 />
                             ))}
                        </div>
                    </div>

                    {/* Floating Action Button (Alternative/Supplement to Quick Add Bar) */}
                    <button
                         onClick={() => setIsAddTaskModalOpen(true)}
                         className="fixed bottom-20 sm:bottom-24 ltr:right-4 rtl:left-4 z-40 btn btn-primary rounded-full p-3 shadow-lg"
                         aria-label={t('addTask')}
                    >
                         <Icon name="plus" className="w-6 h-6" />                    </button>


                    {/* Quick Add Bar (Less prominent now with FAB) */}
                    <form onSubmit={handleQuickAdd} className="fixed bottom-16 left-0 right-0 bg-gray-100 dark:bg-gray-800 p-2 border-t border-gray-200 dark:border-gray-700 flex gap-2 z-40 shadow-inner">
                        <input
                            type="text"
                            value={newTaskTitle}
                            onChange={(e) => setNewTaskTitle(e.target.value)}
                            placeholder={t('quickAddPlaceholder', { date: formatDate(currentDayString, 'jD jMMMM', language) })}
                            className="input-field flex-grow text-sm"
                            aria-label={t('quickAddPlaceholder', { date: formatDate(currentDayString, 'jD jMMMM', language) })}
                        />
                        <button type="submit" className="btn btn-secondary flex-shrink-0 px-3" aria-label={t('add')}>
                            <Icon name="arrow-up-circle" className="w-5 h-5" />
                        </button>
                    </form>

                    {/* Add Task Modal */}
                    <Modal
                        isOpen={isAddTaskModalOpen}
                        onClose={() => setIsAddTaskModalOpen(false)}
                        title={t('addNewTaskTitle')}
                        footerContent={(
                            <Fragment>
                                <button type="button" onClick={() => setIsAddTaskModalOpen(false)} className="btn btn-secondary">{t('cancel')}</button>
                                <button type="submit" form="task-add-form" className="btn btn-primary">{t('saveTask')}</button>
                            </Fragment>
                        )}
                    >
                        <TaskForm
                            key="add-form" /* Ensure form resets */
                            onSave={handleSaveNewTask}
                            onCancel={() => setIsAddTaskModalOpen(false)}
                            // Pass default shownOn date? TaskForm handles empty input for backlog.
                        />
                    </Modal>                </div>
            );
        }

         function BacklogView() {
            const { appData, loading, updateTask } = useContext(DataContext);
            const { t, language } = useContext(I18nContext);
            const [schedulingTaskId, setSchedulingTaskId] = useState(null);            // Store date in input format (Jalali), convert on save
             const [scheduleDateInput, setScheduleDateInput] = useState(formatDate(getTodayStorageString(), 'jYYYY/jMM/jDD', language));

            const backlogTasks = useMemo(() => {
                if (!appData) return [];
                // Sort by creation date descending? Or Priority?
                return Object.values(appData.tasks)
                           .filter(task => task.shownOn === null)
                           .sort((a, b) => (b.priority ? (prioritiesOrder[b.priority] || 0) : 0) - (a.priority ? (prioritiesOrder[a.priority] || 0) : 0) || b.createdAt - a.createdAt);
            }, [appData]);

             const prioritiesOrder = { high: 3, medium: 2, low: 1 }; // For sorting

            const handleScheduleClick = (taskId) => {
                 setSchedulingTaskId(taskId);
                 setScheduleDateInput(formatDate(getTodayStorageString(), 'jYYYY/jMM/jDD', language)); // Default to today in Jalali
            };

            const handleConfirmSchedule = () => {
                 if (!schedulingTaskId) return;
                 const storageDate = toStorageDateString(scheduleDateInput); // Convert from Jalali input
                 if (!storageDate || !isValidStorageDate(storageDate)) {
                      alert(t('invalidDate'));
                      return;
                 }
                 updateTask(schedulingTaskId, { shownOn: storageDate }, "زمان‌بندی وظیفه", true); // Enable undo
                 setSchedulingTaskId(null);
             };

             if (loading && !appData) return <AppLoadingIndicator />;

            return (
                <div className="p-4 pb-20">
                    <h2 className="text-xl font-semibold mb-4">{t('backlog')}</h2>
                    {backlogTasks.length === 0 && <p className="text-center text-sm text-gray-500 dark:text-gray-400 py-6 italic">{t('noBacklogTasks')}</p>}
                    <div className="space-y-3">
                         {backlogTasks.map(task => (
                              <div key={task.id} className="bg-white dark:bg-gray-800 shadow rounded-lg p-3 flex justify-between items-center gap-2">
                                  <div className="flex-grow overflow-hidden">
                                      <span className="font-semibold block truncate">{task.title}</span>
                                       <div className="flex items-center gap-2 text-xs text-gray-500 dark:text-gray-400 mt-1">
                                          {task.priority && <span className={priorityTextClass[task.priority]}>({t(`priority${task.priority.charAt(0).toUpperCase() + task.priority.slice(1)}`)})</span>}
                                           {(task.topics?.length > 0) && <span className="truncate">{task.topics.join(', ')}</span>}
                                       </div>
                                  </div>
                                  <button onClick={() => handleScheduleClick(task.id)} className="btn btn-primary btn-sm flex-shrink-0">
                                     <Icon name="calendar-days" className="w-4 h-4 me-1" /> {t('schedule')}
                                  </button>
                              </div>
                         ))}
                     </div>

                     {/* Scheduling Modal */}
                     <Modal
                         isOpen={!!schedulingTaskId}
                         onClose={() => setSchedulingTaskId(null)}
                         title={t('scheduleTaskTitle')}
                         footerContent={(
                             <Fragment>
                                 <button type="button" onClick={() => setSchedulingTaskId(null)} className="btn btn-secondary">{t('cancel')}</button>
                                 <button type="button" onClick={handleConfirmSchedule} className="btn btn-primary">{t('confirmSchedule')}</button>
                             </Fragment>
                         )}
                     >
                          <div className="space-y-4">
                              <p className="text-sm">{t('scheduleTaskPrompt', { title: appData?.tasks[schedulingTaskId]?.title })}</p>
                              <div>
                                   <label htmlFor="scheduleDate" className="block text-sm font-medium mb-1">{t('scheduleDate')}</label>
                                   {/* Needs a proper Jalali Date Picker Component */}
                                   <input
                                        id="scheduleDate"
                                        type="text"
                                        value={scheduleDateInput}
                                        onChange={e => setScheduleDateInput(e.target.value)}
                                        placeholder={t('datePlaceholderJJJJMMDD')}
                                        className="input-field"
                                    />
                                    <p className="text-xs text-gray-500 mt-1">Format: {t('datePlaceholderJJJJMMDD')}. Gregorian: {formatDate(toStorageDateString(scheduleDateInput), 'YYYY-MM-DD')}</p>
                              </div>
                           </div>
                     </Modal>
                </div>
            );
        }

         function CalendarView() {
             const { appData, loading } = useContext(DataContext);
             const { t, language } = useContext(I18nContext);
              const [currentMonthMoment, setCurrentMonthMoment] = useState(moment().locale(language).startOf('jMonth')); // Start with current Jalali month
              const [selectedDay, setSelectedDay] = useState(null); // Store selected 'YYYY-MM-DD'

             const tasksByDay = useMemo(() => {
                 if (!appData?.tasks) return {};
                 const map = {};
                 Object.values(appData.tasks).forEach(task => {
                     if (task.shownOn) {
                         if (!map[task.shownOn]) map[task.shownOn] = [];
                         map[task.shownOn].push(task);
                     }
                 });
                 return map;
             }, [appData?.tasks]);

             const remindersByDay = useMemo(() => {
                  if (!appData?.reminders) return {};
                  const map = {};
                  const year = currentMonthMoment.year(); // Gregorian year for lunar check

                  // Iterate through days visible in the current calendar month view
                  const startOfMonth = currentMonthMoment.clone().startOf('jMonth').startOf('week');
                   const endOfMonth = currentMonthMoment.clone().endOf('jMonth').endOf('week');

                   for (let m = startOfMonth.clone(); m.isSameOrBefore(endOfMonth); m.add(1, 'day')) {
                        const dayString = m.format('YYYY-MM-DD');
                        const reminders = Object.values(appData.reminders).filter(rem => {
                             const eventMoment = moment(rem.eventDate);
                             if (!eventMoment.isValid()) return false;
                             if (rem.recurrenceRule === 'none' && rem.eventDate === dayString) return true;
                              if (rem.recurrenceRule === 'yearly') {
                                  const format = rem.calendarType === 'Jalali' ? 'jMM-jDD' : 'MM-DD';
                                  if (eventMoment.format(format) === m.format(format)) return true;
                                  if (rem.calendarType === 'Lunar' && rem.lunarEventReference) {
                                       const approxDate = getApproxLunarOffsetDate(m.year(), rem.lunarEventReference, rem.daysOffset || 0);
                                       if (approxDate === dayString) return true;
                                   }
                              }
                               if (rem.recurrenceRule === 'monthly') {
                                   const dayFormat = rem.calendarType === 'Jalali' ? 'jDD' : 'DD';
                                   const targetDay = parseInt(eventMoment.format(dayFormat), 10);
                                    const lastDayOfCurrentMonth = rem.calendarType === 'Jalali' ? m.jDaysInMonth() : m.daysInMonth();
                                    const currentDay = parseInt(m.format(dayFormat), 10);
                                    if (currentDay === Math.min(targetDay, lastDayOfCurrentMonth)) return true;
                               }
                             return false;
                        });
                        if (reminders.length > 0) {
                             map[dayString] = reminders;
                        }
                   }
                   return map;
             }, [appData?.reminders, currentMonthMoment]);


              const changeMonth = (amount) => {
                   setCurrentMonthMoment(prev => prev.clone().add(amount, 'jMonth'));
                   setSelectedDay(null); // Clear selection when changing month
              };

              // Calendar Grid Generation
             const daysInMonthGrid = [];
             const firstDayOfMonth = currentMonthMoment.clone().startOf('jMonth');
             const lastDayOfMonth = currentMonthMoment.clone().endOf('jMonth');
              const firstDayOfGrid = firstDayOfMonth.clone().startOf('week'); // Assumes week starts Sunday based on locale? Adjust if needed.
              const lastDayOfGrid = lastDayOfMonth.clone().endOf('week');

              for (let day = firstDayOfGrid.clone(); day.isSameOrBefore(lastDayOfGrid); day.add(1, 'day')) {
                   daysInMonthGrid.push(day.clone());
              }

             if (loading && !appData) return <AppLoadingIndicator />;

             const selectedDayTasks = selectedDay ? tasksByDay[selectedDay] || [] : [];
             const selectedDayReminders = selectedDay ? remindersByDay[selectedDay] || [] : [];

             return (
                  <div className="p-4 pb-20">
                      {/* Calendar Header */}
                      <div className="flex justify-between items-center mb-4">
                           <button onClick={() => changeMonth(-1)} className="btn-icon" aria-label={t('previousMonth')}>
                               <Icon name={language === 'fa' ? "chevron-right" : "chevron-left"} className="w-6 h-6" />                           </button>
                           <h2 className="text-lg sm:text-xl font-semibold text-center">
                               {currentMonthMoment.format('jMMMM jYYYY')}
                          </h2>
                           <button onClick={() => changeMonth(1)} className="btn-icon" aria-label={t('nextMonth')}>
                               <Icon name={language === 'fa' ? "chevron-left" : "chevron-right"} className="w-6 h-6" />
                           </button>
                      </div>

                      {/* Calendar Grid */}
                      <div className="grid grid-cols-7 gap-px bg-gray-200 dark:bg-gray-700 border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                           {/* Day Headers */}
                           {daysInMonthGrid.slice(0, 7).map(day => (
                               <div key={day.format('dd')} className="text-center py-2 text-xs font-medium text-gray-500 dark:text-gray-400 bg-gray-50 dark:bg-gray-800">
                                   {day.format('ddd')} {/* Abbreviated day name */}
                               </div>
                           ))}
                           {/* Calendar Cells */}
                           {daysInMonthGrid.map(day => {
                                const dayString = day.format('YYYY-MM-DD');
                                const isCurrentMonth = day.isSame(currentMonthMoment, 'jMonth');
                                const isToday = day.isSame(moment(), 'day');
                                const isSelected = dayString === selectedDay;
                                const dayTasks = tasksByDay[dayString] || [];
                                const dayReminders = remindersByDay[dayString] || [];
                                const hasItems = dayTasks.length > 0 || dayReminders.length > 0;

                                return (
                                    <button
                                        key={dayString}
                                        onClick={() => setSelectedDay(dayString)}
                                         className={`relative p-1 sm:p-2 min-h-[60px] sm:min-h-[80px] text-xs sm:text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 z-0 focus:z-10
                                             ${isCurrentMonth ? 'bg-white dark:bg-gray-800' : 'bg-gray-50 dark:bg-gray-800/50 text-gray-400 dark:text-gray-500'}
                                             ${isSelected ? 'ring-2 ring-blue-500 z-10' : ''}
                                         `}
                                         disabled={!isCurrentMonth && !hasItems} // Allow selecting days outside month if they have items? Maybe not.
                                     >
                                         <span className={`absolute top-1 ${language === 'fa' ? 'right-1' : 'left-1'} ${isToday ? 'bg-blue-600 text-white rounded-full h-5 w-5 flex items-center justify-center font-semibold' : ''}`}>
                                             {day.format('jD')}
                                         </span>
                                         {/* Indicators for tasks/reminders */}
                                         {hasItems && isCurrentMonth && (
                                             <div className="absolute bottom-1 left-1 right-1 flex justify-center space-x-1 rtl:space-x-reverse">
                                                 {dayTasks.length > 0 && <span className="block h-1.5 w-1.5 bg-blue-500 rounded-full" title={`${dayTasks.length} tasks`}></span>}
                                                 {dayReminders.length > 0 && <span className="block h-1.5 w-1.5 bg-purple-500 rounded-full" title={`${dayReminders.length} reminders`}></span>}
                                             </div>
                                          )}
                                     </button>
                                );
                           })}
                      </div>

                       {/* Selected Day Details */}
                       {selectedDay && (
                           <div className="mt-6 p-4 border rounded-lg bg-white dark:bg-gray-800 shadow">
                               <h3 className="text-lg font-semibold mb-3">{formatDate(selectedDay, 'dddd, jD jMMMM', language)}</h3>
                                {/* List Tasks */}
                                {selectedDayTasks.length > 0 && (
                                     <div className="mb-3">
                                         <h4 className="text-sm font-medium mb-1 text-blue-600 dark:text-blue-400">{t('tasks')}</h4>
                                         <ul className="space-y-1 text-sm">
                                             {selectedDayTasks.map(task => (
                                                 <li key={task.id} className="flex items-center gap-2">
                                                     <span className={`h-2 w-2 rounded-full flex-shrink-0 ${task.state === 'done' ? 'bg-green-500' : task.state === 'in-progress' ? 'bg-blue-500' : task.state === 'blocked' ? 'bg-red-500': 'bg-gray-400'}`}></span>
                                                      <span className={`${task.state === 'done' || task.state === 'cancelled' ? 'line-through text-gray-500' : ''}`}>{task.title}</span>
                                                 </li>
                                              ))}
                                         </ul>
                                     </div>
                                 )}
                                  {/* List Reminders */}
                                  {selectedDayReminders.length > 0 && (
                                     <div>
                                         <h4 className="text-sm font-medium mb-1 text-purple-600 dark:text-purple-400">{t('reminders')}</h4>
                                         <ul className="space-y-1 text-sm">
                                             {selectedDayReminders.map(rem => (
                                                  <li key={rem.id} className="flex items-center gap-2">
                                                       <span className="h-2 w-2 rounded-full bg-purple-500 flex-shrink-0"></span>
                                                       <span>{rem.title}</span>
                                                  </li>
                                               ))}
                                          </ul>
                                      </div>
                                  )}
                                   {(selectedDayTasks.length === 0 && selectedDayReminders.length === 0) && (
                                       <p className="text-sm text-gray-500 italic">{t('noItemsForSelectedDay')}</p>
                                   )}
                           </div>
                       )}
                  </div>
             );
         }

        function ReportsView() {
            const { appData, loading } = useContext(DataContext);
            const { t, language } = useContext(I18nContext);
             const [startDateInput, setStartDateInput] = useState(formatDate(moment().subtract(7, 'days'), 'jYYYY/jMM/jDD', language));
             const [endDateInput, setEndDateInput] = useState(formatDate(moment(), 'jYYYY/jMM/jDD', language));

            const filteredUpdates = useMemo(() => {
                if (!appData?.updates) return [];
                const start = toStorageDateString(startDateInput);
                const end = toStorageDateString(endDateInput);
                if (!start || !end) return []; // Handle invalid date inputs

                return Object.values(appData.updates)
                    .filter(upd => {
                        const updMoment = moment(upd.timestamp);
                         // Filter by timestamp for more accuracy than dayString
                         return updMoment.isSameOrAfter(moment(start).startOf('day')) &&
                                updMoment.isSameOrBefore(moment(end).endOf('day'));
                    })                    .sort((a, b) => b.timestamp - a.timestamp); // Sort descending
            }, [appData?.updates, startDateInput, endDateInput]);

            const renderUpdateData = useCallback((update) => {
                const taskTitle = appData?.tasks[update.taskId]?.title || t('unknownTask');
                 const reminderTitle = appData?.reminders[update.reminderId]?.title || t('unknownReminder');
                 const generatorTitle = appData?.recurringGenerators[update.generatorId]?.title || t('unknownGenerator');

                switch (update.data?.type) {                   case 'task_created': return t('logTaskCreated', { title: taskTitle });
                   case 'state_change': return t('logStateChange', { title: taskTitle, from: t(`state${update.data.from?.replace('-', '')}`), to: t(`state${update.data.to?.replace('-', '')}`) });
                   case 'subtask_state_change': return t('logSubtaskStateChange', { subTaskText: update.data.subTaskText, title: taskTitle, from: t(`state${update.data.from}`), to: t(`state${update.data.to}`) });
                   case 'delay': return t('logDelay', { title: taskTitle, date: formatDate(update.data.actualToDay, 'jD jMMMM', language), reason: update.data.reason || t('noReason') });
                   case 'scheduled': return t('logScheduled', { title: taskTitle, date: formatDate(update.data.shownOn, 'jD jMMMM', language) });
                   case 'task_deleted': return t('logTaskDeleted', { title: taskTitle }); // Title might be from cache/stale
                    case 'subtask_added': return t('logSubtaskAdded', { subTaskText: update.data.subTaskText, title: taskTitle });
                    case 'subtask_deleted': return t('logSubtaskDeleted', { subTaskText: update.data.subTaskText, title: taskTitle });
                    case 'text_update': return t('logTextUpdate', { title: taskTitle, content: update.data.content }); // May need context
                    case 'priority_change': return t('logPriorityChange', { title: taskTitle, from: t(`priority${update.data.from || 'None'}`), to: t(`priority${update.data.to || 'None'}`) });
                    case 'recurring_instance_created': return t('logRecurringInstanceCreated', { title: taskTitle, generator: generatorTitle });
                     case 'reminder_created': return t('logReminderCreated', { title: reminderTitle });
                      case 'reminder_dismissed': return t('logReminderDismissed', { title: reminderTitle, date: formatDate(update.data.day, 'jD jMMMM', language) });
                      case 'generator_created': return t('logGeneratorCreated', { title: generatorTitle });
                      case 'generator_updated': return t('logGeneratorUpdated', { title: generatorTitle });
                       case 'generator_deleted': return t('logGeneratorDeleted', { title: generatorTitle });
                       case 'undo': return t('logUndo', { action: update.data.revertedActionDescription || t('previousAction') }); // Need to pass description during undo logging
                    // Add more cases for other UpdateData types
                   default: return JSON.stringify(update.data);
                }
            }, [appData, t, language]);


            if (loading && !appData) return <AppLoadingIndicator />;

            return (
                <div className="p-4 pb-20">
                    <h2 className="text-xl font-semibold mb-4">{t('reports')}</h2>

                    {/* Date Range Filter */}
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg">
                        <div>
                             <label htmlFor="startDate" className="block text-sm font-medium mb-1">{t('startDate')}</label>
                             {/* Needs Jalali Picker */}
                             <input type="text" id="startDate" value={startDateInput} onChange={e => setStartDateInput(e.target.value)} className="input-field" placeholder={t('datePlaceholderJJJJMMDD')} />
                        </div>
                        <div>
                             <label htmlFor="endDate" className="block text-sm font-medium mb-1">{t('endDate')}</label>
                             {/* Needs Jalali Picker */}
                             <input type="text" id="endDate" value={endDateInput} onChange={e => setEndDateInput(e.target.value)} className="input-field" placeholder={t('datePlaceholderJJJJMMDD')} />
                        </div>
                    </div>

                    {/* Updates List */}
                    {filteredUpdates.length === 0 && <p className="text-center text-sm text-gray-500 dark:text-gray-400 py-6 italic">{t('noUpdatesInRange')}</p>}
                    <ul className="space-y-3">
                        {filteredUpdates.map(upd => (
                            <li key={upd.id} className="text-sm p-3 bg-white dark:bg-gray-800 rounded shadow-sm">
                                <div className="flex justify-between items-center mb-1">
                                     <span className="text-xs text-gray-500 dark:text-gray-400">{formatDate(upd.timestamp, 'jD jMMMM HH:mm', language)}</span>
                                     {/* Optional: Link to task/reminder/etc */}
                                </div>
                                <p>{renderUpdateData(upd)}</p>
                            </li>
                        ))}
                    </ul>
                </div>
            );        }

        function SettingsView() {
             const { appData, updateSettings, pullData, pushData, exportData, clearOldLogs, addTopic, deleteTopic } = useContext(DataContext);
             const { t, language, setLanguage } = useContext(I18nContext);
             const { theme, setTheme } = useContext(ThemeContext);
              const [newTopic, setNewTopic] = useState('');
              const [logRetention, setLogRetention] = useState(appData?.settings?.logRetentionDays || DEFAULT_LOG_RETENTION_DAYS);

             const handleThemeChange = (e) => setTheme(e.target.value);
             const handleLangChange = (e) => setLanguage(e.target.value);
             const handleLogRetentionChange = (e) => {
                 const value = e.target.value === 'infinite' ? 'infinite' : parseInt(e.target.value, 10);
                 setLogRetention(value);
                 updateSettings({ logRetentionDays: value });
             };
             const handleClearLogs = () => {
                 if (logRetention !== 'infinite') {
                    clearOldLogs(logRetention);                 } else {
                    alert(t('cannotClearInfiniteLogs')); // i18n
                 }
             };
              const handleAddTopic = (e) => {
                  e.preventDefault();
                  addTopic(newTopic);
                  setNewTopic('');
              };

             return (
                 <div className="p-4 pb-20 space-y-8">
                     <h2 className="text-xl font-semibold">{t('settings')}</h2>

                     {/* Appearance */}
                     <section className="space-y-4">
                          <h3 className="text-lg font-medium border-b dark:border-gray-700 pb-1">{t('appearance')}</h3>
                         <div>
                             <label htmlFor="language-select" className="block text-sm font-medium mb-1">{t('language')}</label>
                             <select id="language-select" value={language} onChange={handleLangChange} className="select-field">
                                 <option value="fa">فارسی</option>
                                 <option value="en">English</option>
                             </select>
                         </div>
                          <div>
                              <label htmlFor="theme-select" className="block text-sm font-medium mb-1">{t('theme')}</label>
                              <select id="theme-select" value={theme} onChange={handleThemeChange} className="select-field">
                                  <option value="system">{t('themeSystem')}</option>
                                  <option value="light">{t('themeLight')}</option>
                                  <option value="dark">{t('themeDark')}</option>
                              </select>
                          </div>
                     </section>

                      {/* Topics Management */}
                      <section className="space-y-4">
                           <h3 className="text-lg font-medium border-b dark:border-gray-700 pb-1">{t('manageTopics')}</h3>
                           <form onSubmit={handleAddTopic} className="flex gap-2">
                               <input
                                    type="text"
                                    value={newTopic}
                                    onChange={e => setNewTopic(e.target.value)}
                                    placeholder={t('addNewTopicPlaceholder')}
                                    className="input-field flex-grow"
                                    required
                                />
                                <button type="submit" className="btn btn-secondary flex-shrink-0"><Icon name="plus" /></button>
                           </form>
                           <div className="flex flex-wrap gap-2">
                               {(appData?.topics || []).map(topic => (
                                   <TopicChip key={topic} topic={topic} size="md" onRemove={deleteTopic} />
                               ))}
                           </div>
                      </section>

                      {/* Sync */}
                      <section className="space-y-4">
                           <h3 className="text-lg font-medium border-b dark:border-gray-700 pb-1">{t('sync')}</h3>
                           <div className="space-y-2">
                               <button onClick={pullData} className="w-full btn btn-secondary">{t('syncPull')}</button>
                               <button onClick={pushData} className="w-full btn btn-secondary">{t('syncPush')}</button>
                                {appData?.settings?.lastSyncTimestamp && (
                                    <p className="text-xs text-gray-500 dark:text-gray-400 text-center">{t('lastSync')}: {formatRelativeTime(appData.settings.lastSyncTimestamp, language)}</p>
                                )}
                           </div>
                      </section>

                      {/* Data Management */}
                       <section className="space-y-4">
                           <h3 className="text-lg font-medium border-b dark:border-gray-700 pb-1">{t('dataManagement')}</h3>
                           <div className="space-y-2">
                                <button onClick={exportData} className="w-full btn btn-secondary">{t('exportAll')}</button>
                           </div>
                           <div className="space-y-2 border-t dark:border-gray-700 pt-4">
                                <label htmlFor="logRetention" className="block text-sm font-medium mb-1">{t('logRetentionLabel')}</label>
                                <select id="logRetention" value={logRetention} onChange={handleLogRetentionChange} className="select-field mb-2">
                                    <option value="7">7 {t('days')}</option>
                                     <option value="30">30 {t('days')}</option>
                                     <option value="90">90 {t('days')}</option>
                                     <option value="180">180 {t('days')}</option>
                                     <option value="365">365 {t('days')}</option>
                                     <option value="infinite">{t('infinite')}</option>
                                </select>
                                <button onClick={handleClearLogs} className="w-full btn btn-danger" disabled={logRetention === 'infinite'}>{t('clearOldLogsAction')}</button>
                           </div>
                           {/* Consider adding "Delete All Data" with extreme warnings */}
                       </section>

                 </div>
             );
        }

        // --- Placeholders for Recurring/Reminders Views ---
        function RecurringView() {
             const { t } = useContext(I18nContext);
             // TODO: Implement listing, adding, editing RecurringGenerators
             return <div className="p-4 pb-20"><h2 className="text-xl font-semibold mb-4">{t('recurring')}</h2><p className="italic text-gray-500">{t('featureComingSoon')}</p></div>;
        }
        function RemindersView() {
              const { t } = useContext(I18nContext);
              // TODO: Implement listing, adding, editing Reminders
              return <div className="p-4 pb-20"><h2 className="text-xl font-semibold mb-4">{t('reminders')}</h2><p className="italic text-gray-500">{t('featureComingSoon')}</p></div>;
        }


         // Loading Indicator
         function AppLoadingIndicator() {
              return (
                  <div className="fixed inset-0 flex flex-col justify-center items-center bg-gray-100 dark:bg-gray-900 z-[200]">
                       <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500 mb-4"></div>
                       <p className="text-gray-600 dark:text-gray-400">در حال بارگذاری برنامه...</p> {/* i18n */}
                  </div>
              );
         }


        // --- Main App Component ---
        function App() {
            const { loading, error, appData } = useContext(DataContext);
            const { t } = useContext(I18nContext);
            const [currentView, setCurrentView] = useState('today'); // Default view

            // Define navigation items
             // Icon names from Heroicons Outline set
            const navItems = [
                { id: 'today', label: t('today'), icon: 'home' },
                 { id: 'calendar', label: t('calendar'), icon: 'calendar-days' },
                { id: 'backlog', label: t('backlog'), icon: 'inbox-stack' },
                 // { id: 'recurring', label: t('recurring'), icon: 'arrow-path' }, // Add when view implemented
                 // { id: 'reminders', label: t('reminders'), icon: 'bell' }, // Add when view implemented
                { id: 'reports', label: t('reports'), icon: 'chart-bar-square' },
                { id: 'settings', label: t('settings'), icon: 'cog-6-tooth' },
            ];

            const renderView = () => {
                switch (currentView) {
                    case 'today': return <TodayView />;
                    case 'calendar': return <CalendarView />;
                    case 'backlog': return <BacklogView />;
                     case 'recurring': return <RecurringView />; // Placeholder
                     case 'reminders': return <RemindersView />; // Placeholder
                    case 'reports': return <ReportsView />;
                    case 'settings': return <SettingsView />;
                    default: return <TodayView />;
                }
            };

             // Show critical error overlay if load/save failed critically
            if (error) {
                return <div className="fixed inset-0 flex justify-center items-center bg-red-100 dark:bg-red-900/80 z-[300] p-4 text-center">
                     <div className="p-6 bg-white dark:bg-gray-800 rounded shadow-lg">
                         <h2 className="text-xl font-bold text-red-600 dark:text-red-400 mb-3">{t('criticalErrorTitle')}</h2>
                          <p className="text-gray-700 dark:text-gray-300">{t('criticalErrorDescription')}</p>
                         <pre className="mt-2 p-1 bg-gray-100 dark:bg-gray-700 text-xs text-left rounded max-h-20 overflow-auto">{error}</pre>
                         <button onClick={() => window.location.reload()} className="mt-4 btn btn-primary">{t('reloadApp')}</button>
                     </div>
                </div>;
            }

             // Show loading indicator only during the initial data load phase
             if (loading && !appData) {
                return <AppLoadingIndicator />;
             }


            return (
                <div className="min-h-screen flex flex-col">
                    {/* Main Content Area */}
                    {/* Add role=main for accessibility */}
                    <main role="main" className="flex-grow pb-16"> {/* Pad for bottom nav */}
                        {renderView()}
                    </main>

                    {/* Bottom Navigation */}
                    {/* Add role=navigation */}
                    <nav role="navigation" aria-label={t('mainNavigation')} className="bottom-nav">
                        {navItems.map(item => (
                             <button
                                key={item.id}
                                onClick={() => setCurrentView(item.id)}
                                className={currentView === item.id ? 'active' : ''}
                                aria-current={currentView === item.id ? 'page' : undefined}
                             >
                                 <Icon name={item.icon} solid={currentView === item.id} />
                                 {item.label}
                             </button>
                        ))}
                    </nav>
                </div>
            );
        }

        // --- i18n Translations Object ---
        const translations = {
            fa: {
                appName: "مدیریت توجه",
                today: "امروز",
                backlog: "انتظار",
                reports: "گزارش‌ها",
                settings: "تنظیمات",
                recurring: "دوره‌ای",
                reminders: "یادآورها",
                calendar: "تقویم",
                // Actions
                addTask: "افزودن وظیفه",
                add: "افزودن",
                save: "ذخیره",
                saveChanges: "ذخیره تغییرات",
                saveTask: "ذخیره وظیفه",
                cancel: "لغو",
                delete: "حذف",
                edit: "ویرایش",
                schedule: "زمان‌بندی",
                confirmSchedule: "تایید زمان‌بندی",
                details: "جزئیات",
                close: "بستن",
                confirmDelete: "آیا از حذف این مورد مطمئن هستید؟",                confirmDeleteTask: "آیا از حذف وظیفه «{{title}}» مطمئن هستید؟",
                startAction: "شروع",
                completeAction: "اتمام",
                blockAction: "مسدود",
                unblockAction: "رفع انسداد",
                reopenAction: "بازگشایی",
                 delayTask: "تاخیر",
                 delayTaskTitle: "تاخیر در انجام وظیفه",
                 delayTaskPrompt: "وظیفه «{{title}}» به چه زمانی موکول شود؟",
                 delayNextDay: "فردا",
                 delayNextWeek: "هفته بعد",
                 delayNextMonth: "ماه بعد",
                 delayCustomDate: "انتخاب تاریخ:",
                 delayReasonOptional: "دلیل تاخیر (اختیاری):",
                 confirmDelay: "ثبت تاخیر",
                 dismiss: "رد کردن",
                 // Task Form
                addNewTaskTitle: "وظیفه جدید",
                editTaskTitle: "ویرایش وظیفه",
                taskTitle: "عنوان وظیفه",
                taskDescription: "توضیحات",
                taskPriority: "اولویت",
                priorityNone: "بدون اولویت",
                priorityLow: "کم",
                priorityMedium: "متوسط",
                priorityHigh: "زیاد",
                taskTopics: "موضوعات",
                taskShownOn: "تاریخ نمایش",
                taskDeadline: "مهلت انجام",
                datePlaceholderJJJJMMDD: "مثال: ۱۴۰۳/۰۵/۱۵",
                datePlaceholderOptional: "اختیاری (مثال: ۱۴۰۳/۰۵/۲۰)",
                leaveEmptyForBacklog: "برای افزودن به لیست انتظار، خالی بگذارید.",
                 noTopicsDefined: "موضوعی تعریف نشده است.",
                // Task States
                taskState: "وضعیت",
                statecreated: "ایجاد شده",
                stateinprogress: "در حال انجام",
                stateblocked: "مسدود",                statedone: "انجام شده",
                statecancelled: "لغو شده",
                 // SubTasks
                 subTasks: "وظایف فرعی",
                 addSubTask: "افزودن وظیفه فرعی",
                 addSubTaskPlaceholder: "عنوان وظیفه فرعی جدید...",
                 noSubTasks: "وظیفه فرعی وجود ندارد.",
                 // General UI
                loading: "در حال بارگذاری...",
                noTasks: "وظیفه‌ای برای نمایش وجود ندارد.",
                noTasksForDay: "وظیفه‌ای برای این روز وجود ندارد.",
                noBacklogTasks: "وظیفه‌ای در لیست انتظار نیست.",
                noUpdates: "گزارشی برای نمایش وجود ندارد.",
                noUpdatesInRange: "گزارشی در این بازه زمانی یافت نشد.",
                noReminders: "یادآوری وجود ندارد.",
                noRemindersForDay: "یادآوری برای این روز وجود ندارد.",
                previousDay: "روز قبل",
                nextDay: "روز بعد",
                 previousMonth: "ماه قبل",
                 nextMonth: "ماه بعد",
                 mainNavigation: "منوی اصلی",
                 needsAttention: "نیاز به توجه",
                 lastUpdatedAt: "آخرین بروزرسانی",
                 createdAt: "تاریخ ایجاد",
                 updated: "بروز شد", // Used in relative time maybe?
                 none: "ندارد",
                 unknownTask: "وظیفه نامشخص",
                 unknownReminder: "یادآور نامشخص",
                 unknownGenerator: "مولد نامشخص",
                 noReason: "دلیل ذکر نشده",
                 // Sync
                 sync: "همگام‌سازی",
                 syncPull: "دریافت از سرور",
                 syncPush: "ارسال به سرور",
                 lastSync: "آخرین همگام‌سازی",
                 pullWarning: "تغییرات محلی که از آخرین همگام‌سازی انجام شده ممکن است بازنویسی شوند. ادامه می‌دهید؟",
                 pullSuccess: "اطلاعات با موفقیت از سرور دریافت شد.",
                 pullError: "خطا در دریافت اطلاعات از سرور.",
                 pushSuccess: "اطلاعات با موفقیت به سرور ارسال شد.",
                 pushError: "خطا در ارسال اطلاعات به سرور.",
                 // Settings
                 appearance: "ظاهر برنامه",
                 manageTopics: "مدیریت موضوعات",
                 addNewTopicPlaceholder: "نام موضوع جدید...",
                 dataManagement: "مدیریت اطلاعات",
                 language: "زبان",
                 theme: "پوسته",
                 themeLight: "روشن",
                 themeDark: "تاریک",
                 themeSystem: "مطابق سیستم",
                 logManagement: "مدیریت گزارش‌ها",
                 logRetentionLabel: "نگهداری گزارش‌ها به مدت:",
                 days: "روز",
                 infinite: "نامحدود",                 exportAll: "خروجی همه اطلاعات (JSON)",
                 clearOldLogsAction: "پاک کردن گزارش‌های قدیمی",
                 confirmClearLogs: "آیا از پاک کردن گزارش‌های قدیمی‌تر از مدت زمان انتخاب شده مطمئن هستید؟",
                 cannotClearInfiniteLogs: "امکان پاکسازی خودکار برای حالت نامحدود وجود ندارد.",
                 // Calendar View
                 noItemsForSelectedDay: "موردی برای روز انتخابی وجود ندارد.",
                  // Reports / Logging
                  startDate: "از تاریخ",
                  endDate: "تا تاریخ",
                  logTaskCreated: "وظیفه ایجاد شد: «{{title}}»",
                  logStateChange: "وضعیت وظیفه «{{title}}» تغییر کرد: {{from}} ← {{to}}",
                  logSubtaskStateChange: "وضعیت زیروظیفه «{{subTaskText}}» در «{{title}}» تغییر کرد: {{from}} ← {{to}}",
                  logDelay: "وظیفه «{{title}}» به {{date}} موکول شد. دلیل: {{reason}}",
                  logScheduled: "وظیفه «{{title}}» برای {{date}} زمان‌بندی شد.",
                  logTaskDeleted: "وظیفه حذف شد: «{{title}}»",
                  logSubtaskAdded: "زیروظیفه افزوده شد: «{{subTaskText}}» به «{{title}}»",
                  logSubtaskDeleted: "زیروظیفه حذف شد: «{{subTaskText}}» از «{{title}}»",
                  logTextUpdate: "بروزرسانی متن برای «{{title}}»: {{content}}", // Needs more context usually
                  logPriorityChange: "اولویت وظیفه «{{title}}» تغییر کرد: {{from}} ← {{to}}",
                  logRecurringInstanceCreated: "نمونه وظیفه دوره‌ای «{{title}}» از مولد «{{generator}}» ایجاد شد.",
                  logReminderCreated: "یادآور ایجاد شد: «{{title}}»",
                  logReminderDismissed: "یادآور «{{title}}» برای {{date}} رد شد.",
                  logGeneratorCreated: "مولد وظیفه دوره‌ای ایجاد شد: «{{title}}»",
                  logGeneratorUpdated: "مولد وظیفه دوره‌ای بروز شد: «{{title}}»",
                  logGeneratorDeleted: "مولد وظیفه دوره‌ای حذف شد: «{{title}}»",
                  logUndo: "عمل قبلی ({{action}}) بازگردانی شد.",
                  previousAction: "عمل قبلی", // Fallback undo description
                  // Errors
                  criticalErrorTitle: "خطای بحرانی",
                  criticalErrorDescription: "متاسفانه خطایی رخ داده که مانع اجرای برنامه می‌شود. لطفا صفحه را رفرش کنید.",
                  reloadApp: "بارگذاری مجدد برنامه",
                  invalidDate: "فرمت تاریخ نامعتبر است.",
                   // Reminders
                   lunarApprox: "قمری (تقریبی)",
                   yearly: "سالانه",
                   monthly: "ماهانه",
                   // Placeholders
                   featureComingSoon: "این قابلیت به زودی اضافه خواهد شد.",
                   // Quick Add
                   quickAddPlaceholder: "افزودن سریع وظیفه برای {{date}}...",
            },
            en: {
                appName: "Attention Manager",
                today: "Today",
                backlog: "Backlog",
                reports: "Reports",
                settings: "Settings",
                recurring: "Recurring",
                reminders: "Reminders",
                calendar: "Calendar",
                 // Actions
                 addTask: "Add Task",
                 add: "Add",
                 save: "Save",
                 saveChanges: "Save Changes",
                 saveTask: "Save Task",
                 cancel: "Cancel",
                 delete: "Delete",
                 edit: "Edit",
                 schedule: "Schedule",
                 confirmSchedule: "Confirm Schedule",
                 details: "Details",
                 close: "Close",
                 confirmDelete: "Are you sure you want to delete this item?",
                 confirmDeleteTask: "Are you sure you want to delete the task \"{{title}}\"?",
                 startAction: "Start",
                 completeAction: "Complete",
                 blockAction: "Block",
                 unblockAction: "Unblock",
                 reopenAction: "Reopen",
                 delayTask: "Delay",
                 delayTaskTitle: "Delay Task",
                 delayTaskPrompt: "Delay task \"{{title}}\" until when?",
                 delayNextDay: "Tomorrow",
                 delayNextWeek: "Next Week",
                 delayNextMonth: "Next Month",
                 delayCustomDate: "Select Date:",
                 delayReasonOptional: "Reason for delay (optional):",
                 confirmDelay: "Confirm Delay",
                 dismiss: "Dismiss",
                 // Task Form
                 addNewTaskTitle: "New Task",
                 editTaskTitle: "Edit Task",
                 taskTitle: "Task Title",
                 taskDescription: "Description",
                 taskPriority: "Priority",
                 priorityNone: "None",
                 priorityLow: "Low",
                 priorityMedium: "Medium",
                 priorityHigh: "High",
                 taskTopics: "Topics",
                 taskShownOn: "Shown On Date",
                 taskDeadline: "Deadline",
                 datePlaceholderJJJJMMDD: "e.g., 1403/05/15", // Update for English context maybe?
                 datePlaceholderOptional: "Optional (e.g., 1403/05/20)", // Update for English context maybe?
                 leaveEmptyForBacklog: "Leave empty to add to backlog.",
                 noTopicsDefined: "No topics defined yet.",
                 // Task States
                 taskState: "State",
                 statecreated: "Created",
                 stateinprogress: "In Progress",
                 stateblocked: "Blocked",
                 statedone: "Done",
                 statecancelled: "Cancelled",
                 // SubTasks
                 subTasks: "Sub-Tasks",
                 addSubTask: "Add Sub-Task",
                 addSubTaskPlaceholder: "New sub-task title...",
                 noSubTasks: "No sub-tasks yet.",
                 // General UI
                 loading: "Loading...",
                 noTasks: "No tasks to display.",
                 noTasksForDay: "No tasks scheduled for this day.",
                 noBacklogTasks: "Backlog is empty.",
                 noUpdates: "No updates to display.",
                 noUpdatesInRange: "No updates found in this date range.",
                 noReminders: "No reminders found.",
                 noRemindersForDay: "No reminders for this day.",
                 previousDay: "Previous Day",
                 nextDay: "Next Day",
                 previousMonth: "Previous Month",
                 nextMonth: "Next Month",
                 mainNavigation: "Main Navigation",
                 needsAttention: "Needs Attention",
                 lastUpdatedAt: "Last Updated",
                 createdAt: "Created At",
                 updated: "Updated",
                 none: "None",
                 unknownTask: "Unknown Task",
                 unknownReminder: "Unknown Reminder",
                 unknownGenerator: "Unknown Generator",
                 noReason: "No reason provided",
                 // Sync
                 sync: "Sync",
                 syncPull: "Pull from Server",
                 syncPush: "Push to Server",
                 lastSync: "Last Sync",
                 pullWarning: "Local changes made since the last sync might be overwritten. Proceed?",
                 pullSuccess: "Data successfully pulled from server.",
                 pullError: "Error pulling data from server.",
                 pushSuccess: "Data successfully pushed to server.",
                 pushError: "Error pushing data to server.",
                 // Settings
                 appearance: "Appearance",
                 manageTopics: "Manage Topics",
                 addNewTopicPlaceholder: "New topic name...",
                 dataManagement: "Data Management",
                 language: "Language",
                 theme: "Theme",
                 themeLight: "Light",
                 themeDark: "Dark",
                 themeSystem: "System",
                 logManagement: "Log Management",
                 logRetentionLabel: "Keep logs for:",
                 days: "days",
                 infinite: "Infinite",                 exportAll: "Export All Data (JSON)",
                 clearOldLogsAction: "Clear Old Logs",
                 confirmClearLogs: "Are you sure you want to clear logs older than the selected retention period?",
                 cannotClearInfiniteLogs: "Cannot automatically clear logs when retention is set to infinite.",                  // Calendar View
                 noItemsForSelectedDay: "No items scheduled for the selected day.",
                   // Reports / Logging (Simplified English versions)
                   startDate: "Start Date",
                   endDate: "End Date",
                   logTaskCreated: "Task created: \"{{title}}\"",
                   logStateChange: "Task \"{{title}}\" state changed: {{from}} → {{to}}",
                   logSubtaskStateChange: "Sub-task \"{{subTaskText}}\" on \"{{title}}\" changed: {{from}} → {{to}}",
                   logDelay: "Task \"{{title}}\" delayed to {{date}}. Reason: {{reason}}",
                   logScheduled: "Task \"{{title}}\" scheduled for {{date}}.",
                   logTaskDeleted: "Task deleted: \"{{title}}\"",
                   logSubtaskAdded: "Sub-task added: \"{{subTaskText}}\" to \"{{title}}\"",
                   logSubtaskDeleted: "Sub-task deleted: \"{{subTaskText}}\" from \"{{title}}\"",
                   logTextUpdate: "Text update for \"{{title}}\": {{content}}",
                   logPriorityChange: "Task \"{{title}}\" priority changed: {{from}} → {{to}}",
                   logRecurringInstanceCreated: "Recurring task instance \"{{title}}\" created from \"{{generator}}\".",
                   logReminderCreated: "Reminder created: \"{{title}}\"",
                   logReminderDismissed: "Reminder \"{{title}}\" dismissed for {{date}}.",
                   logGeneratorCreated: "Recurring generator created: \"{{title}}\"",
                   logGeneratorUpdated: "Recurring generator updated: \"{{title}}\"",
                   logGeneratorDeleted: "Recurring generator deleted: \"{{title}}\"",
                   logUndo: "Previous action ({{action}}) undone.",
                   previousAction: "previous action",
                   // Errors
                   criticalErrorTitle: "Critical Error",
                   criticalErrorDescription: "Unfortunately, an error occurred that prevents the application from running. Please refresh the page.",
                   reloadApp: "Reload Application",
                   invalidDate: "Invalid date format.",
                   // Reminders
                   lunarApprox: "Lunar (Approx.)",
                   yearly: "Yearly",
                   monthly: "Monthly",
                   // Placeholders
                   featureComingSoon: "This feature will be added soon.",
                   // Quick Add
                   quickAddPlaceholder: "Quick add task for {{date}}...",
            }
        };

        // --- Render App ---
        const rootElement = document.getElementById('root');
        if (rootElement) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(
                // StrictMode helps catch potential problems in an application.
                // It does not render any visible UI. It activates additional checks and warnings for its descendants.
                <React.StrictMode>
                    <ErrorBoundary>
                         <ToastProvider> {/* Outside DataProvider */}
                            <DataProvider>
                                 {/* Wrap I18nProvider inside DataProvider to access settings */}
                                <I18nProvider>
                                     {/* Wrap ThemeProvider inside DataProvider */}
                                    <ThemeProvider>
                                        <App />
                                    </ThemeProvider>
                                 </I18nProvider>                            </DataProvider>
                         </ToastProvider>
                    </ErrorBoundary>
                </React.StrictMode>
            );
        } else {
            console.error("Root element (#root) not found in the DOM.");
        }

    </script>

</body>
</html>